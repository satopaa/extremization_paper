head(B)
x = s
xl=  min(s)
xr = max(s)
ndx = 17
deg = 3
dx  =  (xr - xl) / ndx
dx
knots  =  seq(xl - deg * dx, xr + deg * dx, by = dx)
knots
xl
P  =  outer(x, knots, tpower, deg)
head(P)
head(x)
Create basis and penalty matrix#
B = bbase(size, min(size), max(size), 17,3)#
K = ncol(B)#
D = diff(diag(K), diff = 2)#
M = t(D) %*% D#
#
matplot(size, B, type = 'l', lty = 1)
knots
x
dim(P)
length(x)
tpower(20, 10, 2)
n  =  dim(P)[2]#
  D  =  diff(diag(n), diff = deg + 1) / (gamma(deg + 1) * dx ^ deg)#
  B  =  (-1) ^ (deg + 1) * P %*% t(D)
head(B)
head(s)
head(bs(s, knots = knots))
lambdaMEAN = 10^3#
lambdaVARI = 300#
Lambda.beta.0 = 1/1000*diag(p)#
Lambda.delta.0 = lambdaVARI*K#
Lambda.gamma.0 = lambdaMEAN*K#
#Lambda.delta.0 = 1/1000*diag(r)#
#Lambda.gamma.0 = 1/1000*diag(r)#
# INITIALIZE:#
mu.alpha.q = matrix(rep(0, n))#
mu.beta.q = matrix(rep(0, p))#
mu.gamma.q = matrix(rep(0, r))#
mu.delta.q = matrix(rep(0, r))#
Sigma.gamma.q = diag(r)#
Sigma.delta.q = diag(r)#
# START:#
library(Matrix)#
#groups = as.matrix(bdiag(lapply(1:n, function(x) rep(1,ni[x]))))#
#
## Step 1:#
S.list = lapply(1:n, function(i) S[i,] %*% t(S[i,]))#
Sigma.beta.q = solve(t(X) %*% X + Lambda.beta.0)#
#
Xmu.beta.q = X %*% mu.beta.q#
tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
mu.Z.star = rep(0, N)#
new.mu.alpha.q = mu.alpha.q#
epsilon = 10^(-5)#
L = NULL#
for(i in 1:10000){#
#
## Step 2: 0.128#
  mu.Z.q = rep(mu.alpha.q, ni) + Xmu.beta.q#
  numer = dnorm(-mu.Z.q)#
  denom = pnorm(-mu.Z.q)#
  mu.Z.star[Y == 1] = mu.Z.q[Y==1] + numer[Y == 1]/(1-denom[Y==1])#
  mu.Z.star[Y == 0] = mu.Z.q[Y==0] - numer[Y == 0]/denom[Y==0]#
#
  ## Step 3: 0.044#
  mu.beta.q = t(t(mu.Z.star - rep(mu.alpha.q,ni)) %*% X %*% Sigma.beta.q)#
  Xmu.beta.q = X %*% mu.beta.q#
#
  ## Step 4: 0.024#
  Sigma.alpha.q = matrix(1/(ni + tau.star))#
  mu.alpha.q = (rowsum(mu.Z.star - Xmu.beta.q, groups.index) + (S%*%mu.gamma.q)*tau.star) * Sigma.alpha.q#
  #mu.alpha.q = alpha#
  #Sigma.alpha.q = matrix(rep(1/1000, n))#
  ## Step 5: 0.000#
  E.resid = Sigma.alpha.q + mu.alpha.q^2 - 2*mu.alpha.q*(S %*% mu.gamma.q) + rowSums((S %*% (Sigma.gamma.q + mu.gamma.q %*% t(mu.gamma.q))) * S)#
  weighted.list = lapply(1:n, function(i) S.list[[i]]*E.resid[i]*tau.star[i])#
  Sigma.delta.q = solve(Lambda.delta.0 + 0.5*Reduce("+", S.list))#
  mu.delta.q = mu.delta.q + Sigma.delta.q %*% (-Lambda.delta.0%*%mu.delta.q + 0.5*colSums(c(1-tau.star*E.resid)*S))#
  tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
#
  ## Step 6: 0.000#
  tau.starS = c(tau.star) * S#
  Sigma.gamma.q = solve(t(S) %*% tau.starS + Lambda.gamma.0)#
  mu.gamma.q = t(t(mu.alpha.q) %*% tau.starS %*% Sigma.gamma.q)#
  old.mu.alpha.q = new.mu.alpha.q#
  new.mu.alpha.q = mu.alpha.q#
  if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon) break#
  cat(paste(i, "Beta error:   ", mean((mu.beta.q - beta)^2), "  "))#
  cat(paste("Alpha error:   ", mean((mu.alpha.q - alpha)^2), "\n"))#
  par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)#
}
Simulate data:#
n = 4300#
#cluster.size = 100#
p = 27#
#
#ni = rep(cluster.size, n)#
ni = sort(round(rgamma(n, 2, 20)*1000))#
N = sum(ni)#
tau = 1/0.1#
#
library(splines)#
#s = runif(n, 0, 2)*1:n/n#
#s = rep(ni,ni)#
s = ni#
#s = scale(s)#
nknots = 4#
##S = bs(s, intercept = TRUE, degree = 3, df = 3+1+nknots)#
#S.true = ns(s, intercept = TRUE, df = 3+1+nknots)#
#knots = unique(s)#
#S = ns(s, intercept = TRUE, knots = knots)#
#
bspl2.2 <- create.bspline.basis(norder=4, breaks= quantile(s))#
S.true <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S.true)#
#
S.true = cbind(1, s)#
#
#gamma = c(-0.3,-0.4, -0.6, -0.9, -1, -1, -1.5)#
gamma = c(-0.5, -0.001)#
plot( S.true %*% gamma~s)#
#delta = c(0.2,0.2,0.3, 0.3, 1.2, 2, 2)#
delta = c(0.1, 0.01)#
plot( exp(-S.true %*% delta)~s)#
alpha = rnorm(n, S.true %*% gamma, sqrt(exp(-S.true %*% delta))) #
alpha.rep = rep(alpha, ni)#
plot(alpha~s)#
#
# In our model, X cannot have an intercept term. This makes the model#
# non-identifiable. Also, be careful with the simulated structure of#
# the predictors.#
X = sapply(1:p, function(x) runif(N, -1, 1)*1:N/N)#
#X = sapply(1:p, function(x) runif(N, -1, 1)*1:N/N)#
#X = rep(1:cluster.size/cluster.size, n)#
#X = cbind(rep(-(cluster.size:1)/cluster.size, n), X)#
beta = sample(c(-1,1), p, replace = TRUE)*(1:p)/p#
eta = alpha.rep + X %*% beta#
probs = pnorm(eta)#
Y = sapply(1:N, function(x) rbinom(1,1,probs[x]))#
##########################################################################################################
## Run the algorithm:#
# PRIORS:#
nknots = 30#
groups.index = rep(1:n, ni)#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = quantile(s, seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = round(diff(range(s))/(nknots+1)*1:nknots)#
#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2))#
#knots = quantile(s, seq(0, 1, length = nknots + 2))#
S = bs(s, intercept = TRUE, knots = knots)#
#S = ns(s, intercept = TRUE, knots = knots)#
#r = ncol(S)#
#bspl2.2 <- create.bspline.basis(norder=4, breaks= knots)#
#S <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S)#
#
library(ppls)#
K = Penalty.matrix(c(ncol(S)),2)#
lambdaMEAN = 10^3#
lambdaVARI = 300#
Lambda.beta.0 = 1/1000*diag(p)#
Lambda.delta.0 = lambdaVARI*K#
Lambda.gamma.0 = lambdaMEAN*K#
#Lambda.delta.0 = 1/1000*diag(r)#
#Lambda.gamma.0 = 1/1000*diag(r)#
# INITIALIZE:#
mu.alpha.q = matrix(rep(0, n))#
mu.beta.q = matrix(rep(0, p))#
mu.gamma.q = matrix(rep(0, r))#
mu.delta.q = matrix(rep(0, r))#
Sigma.gamma.q = diag(r)#
Sigma.delta.q = diag(r)#
# START:#
library(Matrix)#
#groups = as.matrix(bdiag(lapply(1:n, function(x) rep(1,ni[x]))))#
#
## Step 1:#
S.list = lapply(1:n, function(i) S[i,] %*% t(S[i,]))#
Sigma.beta.q = solve(t(X) %*% X + Lambda.beta.0)#
#
Xmu.beta.q = X %*% mu.beta.q#
tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
mu.Z.star = rep(0, N)#
new.mu.alpha.q = mu.alpha.q#
epsilon = 10^(-5)#
L = NULL#
for(i in 1:10000){#
#
## Step 2: 0.128#
  mu.Z.q = rep(mu.alpha.q, ni) + Xmu.beta.q#
  numer = dnorm(-mu.Z.q)#
  denom = pnorm(-mu.Z.q)#
  mu.Z.star[Y == 1] = mu.Z.q[Y==1] + numer[Y == 1]/(1-denom[Y==1])#
  mu.Z.star[Y == 0] = mu.Z.q[Y==0] - numer[Y == 0]/denom[Y==0]#
#
  ## Step 3: 0.044#
  mu.beta.q = t(t(mu.Z.star - rep(mu.alpha.q,ni)) %*% X %*% Sigma.beta.q)#
  Xmu.beta.q = X %*% mu.beta.q#
#
  ## Step 4: 0.024#
  Sigma.alpha.q = matrix(1/(ni + tau.star))#
  mu.alpha.q = (rowsum(mu.Z.star - Xmu.beta.q, groups.index) + (S%*%mu.gamma.q)*tau.star) * Sigma.alpha.q#
  #mu.alpha.q = alpha#
  #Sigma.alpha.q = matrix(rep(1/1000, n))#
  ## Step 5: 0.000#
  E.resid = Sigma.alpha.q + mu.alpha.q^2 - 2*mu.alpha.q*(S %*% mu.gamma.q) + rowSums((S %*% (Sigma.gamma.q + mu.gamma.q %*% t(mu.gamma.q))) * S)#
  weighted.list = lapply(1:n, function(i) S.list[[i]]*E.resid[i]*tau.star[i])#
  Sigma.delta.q = solve(Lambda.delta.0 + 0.5*Reduce("+", S.list))#
  mu.delta.q = mu.delta.q + Sigma.delta.q %*% (-Lambda.delta.0%*%mu.delta.q + 0.5*colSums(c(1-tau.star*E.resid)*S))#
  tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
#
  ## Step 6: 0.000#
  tau.starS = c(tau.star) * S#
  Sigma.gamma.q = solve(t(S) %*% tau.starS + Lambda.gamma.0)#
  mu.gamma.q = t(t(mu.alpha.q) %*% tau.starS %*% Sigma.gamma.q)#
  old.mu.alpha.q = new.mu.alpha.q#
  new.mu.alpha.q = mu.alpha.q#
  if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon) break#
  cat(paste(i, "Beta error:   ", mean((mu.beta.q - beta)^2), "  "))#
  cat(paste("Alpha error:   ", mean((mu.alpha.q - alpha)^2), "\n"))#
  par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)#
}
bbase  =  function(x, xl, xr, ndx, deg){#
  # Function for B-spline basis#
  dx  =  (xr - xl) / ndx#
  knots  =  seq(xl - deg * dx, xr + deg * dx, by = dx)#
  P  =  outer(x, knots, tpower, deg)#
  n  =  dim(P)[2]#
  D  =  diff(diag(n), diff = deg + 1) / (gamma(deg + 1) * dx ^ deg)#
  B  =  (-1) ^ (deg + 1) * P %*% t(D)#
  B #
}#
#
# Create basis and penalty matrix#
B = bbase(size, min(size), max(size), 17,3)#
K = ncol(B)#
D = diff(diag(K), diff = 2)#
M = t(D) %*% D#
#
matplot(size, B, type = 'l', lty = 1)
install.packages("ks", dependencies=TRUE)
install.packages("ks", dependencies=TRUE, type="source")
xc
Run the algorithm:#
# PRIORS:#
nknots = 30#
groups.index = rep(1:n, ni)#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = quantile(s, seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = round(diff(range(s))/(nknots+1)*1:nknots)#
#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2))#
#knots = quantile(s, seq(0, 1, length = nknots + 2))#
S = bs(s, intercept = TRUE, knots = knots)#
#S = ns(s, intercept = TRUE, knots = knots)#
#r = ncol(S)#
#bspl2.2 <- create.bspline.basis(norder=4, breaks= knots)#
#S <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S)#
#
library(ppls)#
K = Penalty.matrix(c(ncol(S)),2)#
lambdaMEAN = 10^3#
lambdaVARI = 300#
Lambda.beta.0 = 1/1000*diag(p)#
Lambda.delta.0 = lambdaVARI*K#
Lambda.gamma.0 = lambdaMEAN*K#
#Lambda.delta.0 = 1/1000*diag(r)#
#Lambda.gamma.0 = 1/1000*diag(r)#
# INITIALIZE:#
mu.alpha.q = matrix(rep(0, n))#
mu.beta.q = matrix(rep(0, p))#
mu.gamma.q = matrix(rep(0, r))#
mu.delta.q = matrix(rep(0, r))#
Sigma.gamma.q = diag(r)#
Sigma.delta.q = diag(r)#
# START:#
library(Matrix)#
#groups = as.matrix(bdiag(lapply(1:n, function(x) rep(1,ni[x]))))#
#
## Step 1:#
S.list = lapply(1:n, function(i) S[i,] %*% t(S[i,]))#
Sigma.beta.q = solve(t(X) %*% X + Lambda.beta.0)#
#
Xmu.beta.q = X %*% mu.beta.q#
tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
mu.Z.star = rep(0, N)#
new.mu.alpha.q = mu.alpha.q#
epsilon = 10^(-5)#
L = NULL#
for(i in 1:10000){#
#
## Step 2: 0.128#
  mu.Z.q = rep(mu.alpha.q, ni) + Xmu.beta.q#
  numer = dnorm(-mu.Z.q)#
  denom = pnorm(-mu.Z.q)#
  mu.Z.star[Y == 1] = mu.Z.q[Y==1] + numer[Y == 1]/(1-denom[Y==1])#
  mu.Z.star[Y == 0] = mu.Z.q[Y==0] - numer[Y == 0]/denom[Y==0]#
#
  ## Step 3: 0.044#
  mu.beta.q = t(t(mu.Z.star - rep(mu.alpha.q,ni)) %*% X %*% Sigma.beta.q)#
  Xmu.beta.q = X %*% mu.beta.q#
#
  ## Step 4: 0.024#
  Sigma.alpha.q = matrix(1/(ni + tau.star))#
  mu.alpha.q = (rowsum(mu.Z.star - Xmu.beta.q, groups.index) + (S%*%mu.gamma.q)*tau.star) * Sigma.alpha.q#
  #mu.alpha.q = alpha#
  #Sigma.alpha.q = matrix(rep(1/1000, n))#
  ## Step 5: 0.000#
  E.resid = Sigma.alpha.q + mu.alpha.q^2 - 2*mu.alpha.q*(S %*% mu.gamma.q) + rowSums((S %*% (Sigma.gamma.q + mu.gamma.q %*% t(mu.gamma.q))) * S)#
  weighted.list = lapply(1:n, function(i) S.list[[i]]*E.resid[i]*tau.star[i])#
  Sigma.delta.q = solve(Lambda.delta.0 + 0.5*Reduce("+", S.list))#
  mu.delta.q = mu.delta.q + Sigma.delta.q %*% (-Lambda.delta.0%*%mu.delta.q + 0.5*colSums(c(1-tau.star*E.resid)*S))#
  tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
#
  ## Step 6: 0.000#
  tau.starS = c(tau.star) * S#
  Sigma.gamma.q = solve(t(S) %*% tau.starS + Lambda.gamma.0)#
  mu.gamma.q = t(t(mu.alpha.q) %*% tau.starS %*% Sigma.gamma.q)#
  old.mu.alpha.q = new.mu.alpha.q#
  new.mu.alpha.q = mu.alpha.q#
  if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon) break#
  cat(paste(i, "Beta error:   ", mean((mu.beta.q - beta)^2), "  "))#
  cat(paste("Alpha error:   ", mean((mu.alpha.q - alpha)^2), "\n"))#
  par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)#
}
library(EWVS)
library(EWVSpackage)
library()
library(EMVS)
library(EMVSpackage)
n = 1000#
cluster.size = 100#
p = 27#
#
#ni = rep(cluster.size, n)#
#ni = round(runif(n, 1, 100))#
#ni = sort(round(rgamma(n, 2, 20)*1000)+1)#
ni = sort(round(rexp(n, 1)*100)+1)#
N = sum(ni)#
#
library(splines)#
#s = runif(n, 0, 2)*1:n/n#
#s = rep(ni,ni)#
#s = scale(ni)#
#s = scale(s)#
s = ni#
nknots = 4#
##S = bs(s, intercept = TRUE, degree = 3, df = 3+1+nknots)#
#S.true = ns(s, intercept = TRUE, df = 3+1+nknots)#
#knots = unique(s)#
#S = ns(s, intercept = TRUE, knots = knots)#
#
library(fda)#
bspl2.2 <- create.bspline.basis(norder=4, breaks= quantile(s))#
S.true <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S.true)#
#
#S.true = cbind(1, s)#
#
gamma = c(-0.3,-0.4, -0.2, -1, -0.5, -1, -1.2)#
                                        #gamma = c(-0.5, -0.001)#
plot( S.true %*% gamma~s)#
#delta = c(-0.2,0.2,0.3, 0.3, 1.2, 2, 2)#
delta = c(1,1,1, 1, 1.2, 2, 2)#
#
                                        #delta = c(0.1, 0.01)#
plot( exp(-S.true %*% delta)~s)#
alpha = rnorm(n, S.true %*% gamma, sqrt(exp(-S.true %*% delta))) #
alpha.rep = rep(alpha, ni)#
plot(alpha~s)#
#
# In our model, X cannot have an intercept term. This makes the model#
# non-identifiable. Also, be careful with the simulated structure of#
# the predictors.#
X = sapply(1:p, function(x) runif(N, -1, 1)*1:N/N)#
#X = sapply(1:p, function(x) runif(N, -1, 1)*1:N/N)#
#X = rep(1:cluster.size/cluster.size, n)#
#X = cbind(rep(-(cluster.size:1)/cluster.size, n), X)#
beta = sample(c(-1,1), p, replace = TRUE)*(1:p)/p#
eta = alpha.rep + X %*% beta#
probs = pnorm(eta)#
Y = sapply(1:N, function(x) rbinom(1,1,probs[x]))
dd = data.frame(Y,X)#
ID = rep(1:n,ni)
dim(dd)
dd = data.frame(Y,X)#
ID = rep(1:n,ni)#
glmm = glmmPQL(Y~-1+., random  = ~1+S | ID,family = binomial, data = dd)
library(MASS)#
dd = data.frame(Y,X)#
ID = rep(1:n,ni)#
glmm = glmmPQL(Y~-1+., random  = ~1+S | ID,family = binomial, data = dd)
glmm = glmmPQL(Y~-1+., random  = ~1+S.true | ID,family = binomial, data = dd)
dim(S.true)
glmm = glmmPQL(Y~-1+., random  = ~1 | ID,family = binomial, data = dd)
names(glmm)
glmm$coefficients
names(glmm$coefficients)
glmm$coefficients$fixed
head(dd)
glmm = glmmPQL(Y~-1+X1+X2+X3+X4+X5+X6+X7+X8+X9+X10+X11+X12+X13+X14+X15+X16+X17+X18+X19+X20+X21+X22+X23+X24+X25+X26+X27, random  = ~1 | ID,family = binomial, data = dd)
glmm$coefficients$fixed
glmm$coefficients$random
head(glmm$coefficients$random)
head(glmm$coefficients$random[[1]])
mu.alpha.q = glmm$coefficients$random[[1]]
mu.alpha.q
Run the algorithm:#
# PRIORS:#
nknots = 40#
groups.index = rep(1:n, ni)#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
#knots = quantile(s, seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = round(diff(range(s))/(nknots+1)*1:nknots)#
#knots = diff(range(s))/(nknots+1)*1:nknots#
#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2))#
#knots = quantile(s, seq(0, 1, length = nknots + 2))#
S = bs(s, intercept = TRUE, knots = knots)#
#S = ns(s, intercept = TRUE, knots = knots)#
#r = ncol(S)#
#bspl2.2 <- create.bspline.basis(norder=4, breaks= knots)#
#S <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S)#
#
## The goal with this fix is to reduce the wiggliness at the high-end#
## where only a few observations are given. It is reasonable to assume#
## that with only a few widely spread out observations, the line#
## through the data is the best option.#
library(ppls)#
K = Penalty.matrix(c(ncol(S)),2)#
diags <- list(rep(1, r), rep(-2, r), rep(1, r))#
A <- bandSparse(r, k = c(0:2), diag =diags, symm=FALSE)#
A = as.matrix(A)#
A[1:2, 1:2] = 0#
counts = apply(S, 2, function(x) sum(x > 0))#
counts = ifelse(counts == 0, 10^{-6}, counts)#
K.gamma = A %*% diag(1/counts) %*% t(A)#
K.delta = A %*% t(A)#
#K.delta = K.gamma#
#
a.0 = 1#
#b.0 = 10^{-6}#
#a.0 = 0.001#
b.0 = 0.0001#
Lambda.beta.0 = 1/1000*diag(p)#
# INITIALIZE:#
#mu.alpha.q = matrix(rep(0, n))#
#mu.beta.q = matrix(rep(0, p))#
mu.alpha.q = glmm$coefficients$random[[1]]#
mu.beta.q = glmm$coefficients$fixed#
mu.gamma.q = matrix(rep(0, r))#
mu.delta.q = matrix(rep(0, r))#
Sigma.gamma.q = diag(r)#
Sigma.delta.q = diag(r)#
b.gamma.q = b.0#
b.delta.q = b.0#
tr = function(X) sum(diag(X))#
# START:#
library(Matrix)#
#groups = as.matrix(bdiag(lapply(1:n, function(x) rep(1,ni[x]))))#
#
## Step 1:#
S.list = lapply(1:n, function(i) S[i,] %*% t(S[i,]))#
Sigma.beta.q = solve(t(X) %*% X + Lambda.beta.0)#
a.gamma.q = a.0 + ncol(K.gamma)/2#
a.delta.q = a.0 + ncol(K.delta)/2#
#
Xmu.beta.q = X %*% mu.beta.q#
tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
mu.Z.star = rep(0, N)#
new.mu.alpha.q = mu.alpha.q#
new.b.delta.q = b.delta.q#
epsilon = 10^(-5)#
L = NULL#
for(i in 1:10000){#
#
## Step 2: 0.128#
  mu.Z.q = rep(mu.alpha.q, ni) + Xmu.beta.q#
  numer = dnorm(-mu.Z.q)#
  denom = pnorm(-mu.Z.q)#
  mu.Z.star[Y == 1] = mu.Z.q[Y==1] + numer[Y == 1]/(1-denom[Y==1])#
  mu.Z.star[Y == 0] = mu.Z.q[Y==0] - numer[Y == 0]/denom[Y==0]#
#
  ## Step 3: 0.044#
  mu.beta.q = t(t(mu.Z.star - rep(mu.alpha.q,ni)) %*% X %*% Sigma.beta.q)#
  Xmu.beta.q = X %*% mu.beta.q#
#
  ## Step 4: 0.024#
  Sigma.alpha.q = matrix(1/(ni + tau.star))#
  mu.alpha.q = (rowsum(mu.Z.star - Xmu.beta.q, groups.index) + (S%*%mu.gamma.q)*tau.star) * Sigma.alpha.q#
  mu.alpha.q = alpha#
  Sigma.alpha.q = matrix(rep(1/1000, n))#
  ## Step 5: 0.000#
  E.resid = Sigma.alpha.q + mu.alpha.q^2 - 2*mu.alpha.q*(S %*% mu.gamma.q) + rowSums((S %*% (Sigma.gamma.q + mu.gamma.q %*% t(mu.gamma.q))) * S)#
  weighted.list = lapply(1:n, function(i) S.list[[i]]*E.resid[i]*tau.star[i])#
  Sigma.delta.q = solve(a.delta.q/b.delta.q * K.delta + 0.5*Reduce("+", S.list))#
  mu.delta.q = mu.delta.q + Sigma.delta.q %*% (-(a.delta.q/b.delta.q*K.delta)%*%mu.delta.q + 0.5*colSums(c(1-tau.star*E.resid)*S))#
  tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
#
  ## Step 6: 0.000#
  tau.starS = c(tau.star) * S#
  Sigma.gamma.q = solve(t(S) %*% tau.starS + a.gamma.q/b.gamma.q * K.gamma)#
  mu.gamma.q = t(t(mu.alpha.q) %*% tau.starS %*% Sigma.gamma.q)#
#
  ## Step 7:#
  #old.b.gamma.q = b.gamma.q#
  b.gamma.q = as.numeric(b.0 + 0.5*(tr(K.gamma %*% Sigma.gamma.q) + t(mu.gamma.q)%*%K.gamma%*%mu.gamma.q))#
  #b.gamma.q = 0.001#
  ## Step 8:#
  b.delta.q = as.numeric(b.0 + 0.5*(tr(K.delta %*% Sigma.delta.q) + t(mu.delta.q)%*%K.delta%*%mu.delta.q))#
  #b.delta.q = 0.001#
  old.mu.alpha.q = new.mu.alpha.q#
  new.mu.alpha.q = mu.alpha.q#
#
  old.b.delta.q = new.b.delta.q#
  new.b.delta.q = b.delta.q#
#
  if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon && abs(a.delta.q/old.b.delta.q - a.delta.q/new.b.delta.q) < epsilon) break#
  #if(abs(old.b.gamma.q - b.gamma.q) < epsilon) break#
  cat(paste(i, "Beta error:   ", mean((mu.beta.q - beta)^2), "  "))#
  cat(paste("Alpha error:   ", mean((mu.alpha.q - alpha)^2), "\n"))#
  cat(paste("lambda.gamma:   ", a.gamma.q / b.gamma.q, "   lambda.delta:   ", a.delta.q / b.delta.q,  "\n"))#
  par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)#
}
Run the algorithm:#
# PRIORS:#
nknots = 40#
groups.index = rep(1:n, ni)#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
#knots = quantile(s, seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = round(diff(range(s))/(nknots+1)*1:nknots)#
#knots = diff(range(s))/(nknots+1)*1:nknots#
#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2))#
#knots = quantile(s, seq(0, 1, length = nknots + 2))#
S = bs(s, intercept = TRUE, knots = knots)#
#S = ns(s, intercept = TRUE, knots = knots)#
#r = ncol(S)#
#bspl2.2 <- create.bspline.basis(norder=4, breaks= knots)#
#S <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S)#
#
## The goal with this fix is to reduce the wiggliness at the high-end#
## where only a few observations are given. It is reasonable to assume#
## that with only a few widely spread out observations, the line#
## through the data is the best option.#
library(ppls)#
K = Penalty.matrix(c(ncol(S)),2)#
diags <- list(rep(1, r), rep(-2, r), rep(1, r))#
A <- bandSparse(r, k = c(0:2), diag =diags, symm=FALSE)#
A = as.matrix(A)#
A[1:2, 1:2] = 0#
counts = apply(S, 2, function(x) sum(x > 0))#
counts = ifelse(counts == 0, 10^{-6}, counts)#
K.gamma = A %*% diag(1/counts) %*% t(A)#
K.delta = A %*% t(A)#
#K.delta = K.gamma#
#
a.0 = 1#
#b.0 = 10^{-6}#
#a.0 = 0.001#
b.0 = 0.0001#
Lambda.beta.0 = 1/1000*diag(p)#
# INITIALIZE:#
#mu.alpha.q = matrix(rep(0, n))#
#mu.beta.q = matrix(rep(0, p))#
mu.alpha.q = glmm$coefficients$random[[1]]#
mu.beta.q = glmm$coefficients$fixed#
mu.gamma.q = matrix(rep(0, r))#
mu.delta.q = matrix(rep(0, r))#
Sigma.gamma.q = diag(r)#
Sigma.delta.q = diag(r)#
b.gamma.q = b.0#
b.delta.q = b.0#
tr = function(X) sum(diag(X))#
# START:#
library(Matrix)#
#groups = as.matrix(bdiag(lapply(1:n, function(x) rep(1,ni[x]))))#
#
## Step 1:#
S.list = lapply(1:n, function(i) S[i,] %*% t(S[i,]))#
Sigma.beta.q = solve(t(X) %*% X + Lambda.beta.0)#
a.gamma.q = a.0 + ncol(K.gamma)/2#
a.delta.q = a.0 + ncol(K.delta)/2#
#
Xmu.beta.q = X %*% mu.beta.q#
tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
mu.Z.star = rep(0, N)#
new.mu.alpha.q = mu.alpha.q#
new.b.delta.q = b.delta.q#
epsilon = 10^(-5)#
L = NULL#
for(i in 1:10000){#
#
## Step 2: 0.128#
  mu.Z.q = rep(mu.alpha.q, ni) + Xmu.beta.q#
  numer = dnorm(-mu.Z.q)#
  denom = pnorm(-mu.Z.q)#
  mu.Z.star[Y == 1] = mu.Z.q[Y==1] + numer[Y == 1]/(1-denom[Y==1])#
  mu.Z.star[Y == 0] = mu.Z.q[Y==0] - numer[Y == 0]/denom[Y==0]#
#
  ## Step 3: 0.044#
  mu.beta.q = t(t(mu.Z.star - rep(mu.alpha.q,ni)) %*% X %*% Sigma.beta.q)#
  Xmu.beta.q = X %*% mu.beta.q#
#
  ## Step 4: 0.024#
  Sigma.alpha.q = matrix(1/(ni + tau.star))#
  mu.alpha.q = (rowsum(mu.Z.star - Xmu.beta.q, groups.index) + (S%*%mu.gamma.q)*tau.star) * Sigma.alpha.q#
  #mu.alpha.q = alpha#
  #Sigma.alpha.q = matrix(rep(1/1000, n))#
  ## Step 5: 0.000#
  E.resid = Sigma.alpha.q + mu.alpha.q^2 - 2*mu.alpha.q*(S %*% mu.gamma.q) + rowSums((S %*% (Sigma.gamma.q + mu.gamma.q %*% t(mu.gamma.q))) * S)#
  weighted.list = lapply(1:n, function(i) S.list[[i]]*E.resid[i]*tau.star[i])#
  Sigma.delta.q = solve(a.delta.q/b.delta.q * K.delta + 0.5*Reduce("+", S.list))#
  mu.delta.q = mu.delta.q + Sigma.delta.q %*% (-(a.delta.q/b.delta.q*K.delta)%*%mu.delta.q + 0.5*colSums(c(1-tau.star*E.resid)*S))#
  tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
#
  ## Step 6: 0.000#
  tau.starS = c(tau.star) * S#
  Sigma.gamma.q = solve(t(S) %*% tau.starS + a.gamma.q/b.gamma.q * K.gamma)#
  mu.gamma.q = t(t(mu.alpha.q) %*% tau.starS %*% Sigma.gamma.q)#
#
  ## Step 7:#
  #old.b.gamma.q = b.gamma.q#
  b.gamma.q = as.numeric(b.0 + 0.5*(tr(K.gamma %*% Sigma.gamma.q) + t(mu.gamma.q)%*%K.gamma%*%mu.gamma.q))#
  #b.gamma.q = 0.001#
  ## Step 8:#
  b.delta.q = as.numeric(b.0 + 0.5*(tr(K.delta %*% Sigma.delta.q) + t(mu.delta.q)%*%K.delta%*%mu.delta.q))#
  #b.delta.q = 0.001#
  old.mu.alpha.q = new.mu.alpha.q#
  new.mu.alpha.q = mu.alpha.q#
#
  old.b.delta.q = new.b.delta.q#
  new.b.delta.q = b.delta.q#
#
  if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon && abs(a.delta.q/old.b.delta.q - a.delta.q/new.b.delta.q) < epsilon) break#
  #if(abs(old.b.gamma.q - b.gamma.q) < epsilon) break#
  cat(paste(i, "Beta error:   ", mean((mu.beta.q - beta)^2), "  "))#
  cat(paste("Alpha error:   ", mean((mu.alpha.q - alpha)^2), "\n"))#
  cat(paste("lambda.gamma:   ", a.gamma.q / b.gamma.q, "   lambda.delta:   ", a.delta.q / b.delta.q,  "\n"))#
  par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)#
}
START:#
library(Matrix)#
#groups = as.matrix(bdiag(lapply(1:n, function(x) rep(1,ni[x]))))#
#
## Step 1:#
S.list = lapply(1:n, function(i) S[i,] %*% t(S[i,]))#
Sigma.beta.q = solve(t(X) %*% X + Lambda.beta.0)#
a.gamma.q = a.0 + ncol(K.gamma)/2#
a.delta.q = a.0 + ncol(K.delta)/2#
#
Xmu.beta.q = X %*% mu.beta.q#
tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
mu.Z.star = rep(0, N)#
new.mu.alpha.q = mu.alpha.q#
new.b.delta.q = b.delta.q#
epsilon = 10^(-5)#
L = NULL#
for(i in 1:10000){#
#
## Step 2: 0.128#
  mu.Z.q = rep(mu.alpha.q, ni) + Xmu.beta.q#
  numer = dnorm(-mu.Z.q)#
  denom = pnorm(-mu.Z.q)#
  mu.Z.star[Y == 1] = mu.Z.q[Y==1] + numer[Y == 1]/(1-denom[Y==1])#
  mu.Z.star[Y == 0] = mu.Z.q[Y==0] - numer[Y == 0]/denom[Y==0]#
#
  ## Step 3: 0.044#
  mu.beta.q = t(t(mu.Z.star - rep(mu.alpha.q,ni)) %*% X %*% Sigma.beta.q)#
  Xmu.beta.q = X %*% mu.beta.q#
#
  ## Step 4: 0.024#
  Sigma.alpha.q = matrix(1/(ni + tau.star))#
  mu.alpha.q = (rowsum(mu.Z.star - Xmu.beta.q, groups.index) + (S%*%mu.gamma.q)*tau.star) * Sigma.alpha.q#
  #mu.alpha.q = alpha#
  #Sigma.alpha.q = matrix(rep(1/1000, n))#
  ## Step 5: 0.000#
  E.resid = Sigma.alpha.q + mu.alpha.q^2 - 2*mu.alpha.q*(S %*% mu.gamma.q) + rowSums((S %*% (Sigma.gamma.q + mu.gamma.q %*% t(mu.gamma.q))) * S)#
  weighted.list = lapply(1:n, function(i) S.list[[i]]*E.resid[i]*tau.star[i])#
  Sigma.delta.q = solve(a.delta.q/b.delta.q * K.delta + 0.5*Reduce("+", S.list))#
  mu.delta.q = mu.delta.q + Sigma.delta.q %*% (-(a.delta.q/b.delta.q*K.delta)%*%mu.delta.q + 0.5*colSums(c(1-tau.star*E.resid)*S))#
  tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
#
  ## Step 6: 0.000#
  tau.starS = c(tau.star) * S#
  Sigma.gamma.q = solve(t(S) %*% tau.starS + a.gamma.q/b.gamma.q * K.gamma)#
  mu.gamma.q = t(t(mu.alpha.q) %*% tau.starS %*% Sigma.gamma.q)#
#
  ## Step 7:#
  #old.b.gamma.q = b.gamma.q#
  b.gamma.q = as.numeric(b.0 + 0.5*(tr(K.gamma %*% Sigma.gamma.q) + t(mu.gamma.q)%*%K.gamma%*%mu.gamma.q))#
  #b.gamma.q = 0.001#
  ## Step 8:#
  b.delta.q = as.numeric(b.0 + 0.5*(tr(K.delta %*% Sigma.delta.q) + t(mu.delta.q)%*%K.delta%*%mu.delta.q))#
  #b.delta.q = 0.001#
  old.mu.alpha.q = new.mu.alpha.q#
  new.mu.alpha.q = mu.alpha.q#
#
  old.b.delta.q = new.b.delta.q#
  new.b.delta.q = b.delta.q#
#
  #if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon && abs(a.delta.q/old.b.delta.q - a.delta.q/new.b.delta.q) < epsilon) break#
  if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon) break#
  #if(abs(old.b.gamma.q - b.gamma.q) < epsilon) break#
  cat(paste(i, "Beta error:   ", mean((mu.beta.q - beta)^2), "  "))#
  cat(paste("Alpha error:   ", mean((mu.alpha.q - alpha)^2), "\n"))#
  cat(paste("lambda.gamma:   ", a.gamma.q / b.gamma.q, "   lambda.delta:   ", a.delta.q / b.delta.q,  "\n"))#
  par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)#
}#
#
plot(mu.alpha.q~s)#
plot(alpha~s)
Run the algorithm:#
# PRIORS:#
nknots = 40#
groups.index = rep(1:n, ni)#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
#knots = quantile(s, seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = round(diff(range(s))/(nknots+1)*1:nknots)#
#knots = diff(range(s))/(nknots+1)*1:nknots#
#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2))#
#knots = quantile(s, seq(0, 1, length = nknots + 2))#
S = bs(s, intercept = TRUE, knots = knots)#
#S = ns(s, intercept = TRUE, knots = knots)#
#r = ncol(S)#
#bspl2.2 <- create.bspline.basis(norder=4, breaks= knots)#
#S <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S)#
#
## The goal with this fix is to reduce the wiggliness at the high-end#
## where only a few observations are given. It is reasonable to assume#
## that with only a few widely spread out observations, the line#
## through the data is the best option.#
library(ppls)#
K = Penalty.matrix(c(ncol(S)),2)#
diags <- list(rep(1, r), rep(-2, r), rep(1, r))#
A <- bandSparse(r, k = c(0:2), diag =diags, symm=FALSE)#
A = as.matrix(A)#
A[1:2, 1:2] = 0#
counts = apply(S, 2, function(x) sum(x > 0))#
counts = ifelse(counts == 0, 10^{-6}, counts)#
K.gamma = A %*% diag(1/counts) %*% t(A)#
K.delta = A %*% t(A)#
#K.delta = K.gamma#
#
a.0 = 1#
#b.0 = 10^{-6}#
#a.0 = 0.001#
b.0 = 0.0001#
Lambda.beta.0 = 1/1000*diag(p)#
# INITIALIZE:#
#mu.alpha.q = matrix(rep(0, n))#
#mu.beta.q = matrix(rep(0, p))#
mu.alpha.q = glmm$coefficients$random[[1]]#
mu.beta.q = glmm$coefficients$fixed#
mu.gamma.q = matrix(rep(0, r))#
mu.delta.q = matrix(rep(0, r))#
Sigma.gamma.q = diag(r)#
Sigma.delta.q = diag(r)#
b.gamma.q = b.0#
b.delta.q = b.0#
tr = function(X) sum(diag(X))#
# START:#
library(Matrix)#
#groups = as.matrix(bdiag(lapply(1:n, function(x) rep(1,ni[x]))))#
#
## Step 1:#
S.list = lapply(1:n, function(i) S[i,] %*% t(S[i,]))#
Sigma.beta.q = solve(t(X) %*% X + Lambda.beta.0)#
a.gamma.q = a.0 + ncol(K.gamma)/2#
a.delta.q = a.0 + ncol(K.delta)/2#
#
Xmu.beta.q = X %*% mu.beta.q#
tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
mu.Z.star = rep(0, N)#
new.mu.alpha.q = mu.alpha.q#
new.b.delta.q = b.delta.q#
epsilon = 10^(-5)#
L = NULL#
for(i in 1:10000){#
#
## Step 2: 0.128#
  mu.Z.q = rep(mu.alpha.q, ni) + Xmu.beta.q#
  numer = dnorm(-mu.Z.q)#
  denom = pnorm(-mu.Z.q)#
  mu.Z.star[Y == 1] = mu.Z.q[Y==1] + numer[Y == 1]/(1-denom[Y==1])#
  mu.Z.star[Y == 0] = mu.Z.q[Y==0] - numer[Y == 0]/denom[Y==0]#
#
  ## Step 3: 0.044#
  mu.beta.q = t(t(mu.Z.star - rep(mu.alpha.q,ni)) %*% X %*% Sigma.beta.q)#
  Xmu.beta.q = X %*% mu.beta.q#
#
  ## Step 4: 0.024#
  Sigma.alpha.q = matrix(1/(ni + tau.star))#
  mu.alpha.q = (rowsum(mu.Z.star - Xmu.beta.q, groups.index) + (S%*%mu.gamma.q)*tau.star) * Sigma.alpha.q#
  #mu.alpha.q = alpha#
  #Sigma.alpha.q = matrix(rep(1/1000, n))#
  ## Step 5: 0.000#
  E.resid = Sigma.alpha.q + mu.alpha.q^2 - 2*mu.alpha.q*(S %*% mu.gamma.q) + rowSums((S %*% (Sigma.gamma.q + mu.gamma.q %*% t(mu.gamma.q))) * S)#
  weighted.list = lapply(1:n, function(i) S.list[[i]]*E.resid[i]*tau.star[i])#
  Sigma.delta.q = solve(a.delta.q/b.delta.q * K.delta + 0.5*Reduce("+", S.list))#
  mu.delta.q = mu.delta.q + Sigma.delta.q %*% (-(a.delta.q/b.delta.q*K.delta)%*%mu.delta.q + 0.5*colSums(c(1-tau.star*E.resid)*S))#
  tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
#
  ## Step 6: 0.000#
  tau.starS = c(tau.star) * S#
  Sigma.gamma.q = solve(t(S) %*% tau.starS + a.gamma.q/b.gamma.q * K.gamma)#
  mu.gamma.q = t(t(mu.alpha.q) %*% tau.starS %*% Sigma.gamma.q)#
#
  ## Step 7:#
  #old.b.gamma.q = b.gamma.q#
  b.gamma.q = as.numeric(b.0 + 0.5*(tr(K.gamma %*% Sigma.gamma.q) + t(mu.gamma.q)%*%K.gamma%*%mu.gamma.q))#
  #b.gamma.q = 0.001#
  ## Step 8:#
  b.delta.q = as.numeric(b.0 + 0.5*(tr(K.delta %*% Sigma.delta.q) + t(mu.delta.q)%*%K.delta%*%mu.delta.q))#
  #b.delta.q = 0.001#
  old.mu.alpha.q = new.mu.alpha.q#
  new.mu.alpha.q = mu.alpha.q#
#
  old.b.delta.q = new.b.delta.q#
  new.b.delta.q = b.delta.q#
#
  #if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon && abs(a.delta.q/old.b.delta.q - a.delta.q/new.b.delta.q) < epsilon) break#
  if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon) break#
  #if(abs(old.b.gamma.q - b.gamma.q) < epsilon) break#
  cat(paste(i, "Beta error:   ", mean((mu.beta.q - beta)^2), "  "))#
  cat(paste("Alpha error:   ", mean((mu.alpha.q - alpha)^2), "\n"))#
  cat(paste("lambda.gamma:   ", a.gamma.q / b.gamma.q, "   lambda.delta:   ", a.delta.q / b.delta.q,  "\n"))#
  par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)#
}#
#
plot(mu.alpha.q~s)#
plot(alpha~s)
Simulate data:#
#n = 4300#
n = 2000#
cluster.size = 100#
p = 27#
#
#ni = rep(cluster.size, n)#
#ni = round(runif(n, 1, 100))#
#ni = sort(round(rgamma(n, 2, 20)*1000)+1)#
ni = sort(round(rexp(n, 1)*100)+1)#
N = sum(ni)#
#
library(splines)#
#s = runif(n, 0, 2)*1:n/n#
#s = rep(ni,ni)#
#s = scale(ni)#
#s = scale(s)#
s = ni#
nknots = 4#
##S = bs(s, intercept = TRUE, degree = 3, df = 3+1+nknots)#
#S.true = ns(s, intercept = TRUE, df = 3+1+nknots)#
#knots = unique(s)#
#S = ns(s, intercept = TRUE, knots = knots)#
#
library(fda)#
bspl2.2 <- create.bspline.basis(norder=4, breaks= quantile(s))#
S.true <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S.true)#
#
#S.true = cbind(1, s)#
#
gamma = c(-0.3,-0.4, -0.2, -1, -0.5, -1, -1.2)#
                                        #gamma = c(-0.5, -0.001)#
plot( S.true %*% gamma~s)#
#delta = c(-0.2,0.2,0.3, 0.3, 1.2, 2, 2)#
delta = c(1,1,1, 1, 1.2, 2, 2)#
#
                                        #delta = c(0.1, 0.01)#
plot( exp(-S.true %*% delta)~s)#
alpha = rnorm(n, S.true %*% gamma, sqrt(exp(-S.true %*% delta))) #
alpha.rep = rep(alpha, ni)#
plot(alpha~s)#
#
# In our model, X cannot have an intercept term. This makes the model#
# non-identifiable. Also, be careful with the simulated structure of#
# the predictors.#
X = sapply(1:p, function(x) runif(N, -1, 1)*1:N/N)#
#X = sapply(1:p, function(x) runif(N, -1, 1)*1:N/N)#
#X = rep(1:cluster.size/cluster.size, n)#
#X = cbind(rep(-(cluster.size:1)/cluster.size, n), X)#
beta = sample(c(-1,1), p, replace = TRUE)*(1:p)/p#
eta = alpha.rep + X %*% beta#
probs = pnorm(eta)#
Y = sapply(1:N, function(x) rbinom(1,1,probs[x]))#
#
library(MASS)#
dd = data.frame(Y,X)#
ID = rep(1:n,ni)#
glmm = glmmPQL(Y~-1+X1+X2+X3+X4+X5+X6+X7+X8+X9+X10+X11+X12+X13+X14+X15+X16+X17+X18+X19+X20+X21+X22+X23+X24+X25+X26+X27, random  = ~1 | ID,family = binomial, data = dd)#
##########################################################################################################
## Run the algorithm:#
# PRIORS:#
nknots = 40#
groups.index = rep(1:n, ni)#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
#knots = quantile(s, seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = round(diff(range(s))/(nknots+1)*1:nknots)#
#knots = diff(range(s))/(nknots+1)*1:nknots#
#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2))#
#knots = quantile(s, seq(0, 1, length = nknots + 2))#
S = bs(s, intercept = TRUE, knots = knots)#
#S = ns(s, intercept = TRUE, knots = knots)#
#r = ncol(S)#
#bspl2.2 <- create.bspline.basis(norder=4, breaks= knots)#
#S <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S)#
#
## The goal with this fix is to reduce the wiggliness at the high-end#
## where only a few observations are given. It is reasonable to assume#
## that with only a few widely spread out observations, the line#
## through the data is the best option.#
library(ppls)#
K = Penalty.matrix(c(ncol(S)),2)#
diags <- list(rep(1, r), rep(-2, r), rep(1, r))#
A <- bandSparse(r, k = c(0:2), diag =diags, symm=FALSE)#
A = as.matrix(A)#
A[1:2, 1:2] = 0#
counts = apply(S, 2, function(x) sum(x > 0))#
counts = ifelse(counts == 0, 10^{-6}, counts)#
K.gamma = A %*% diag(1/counts) %*% t(A)#
K.delta = A %*% t(A)#
#K.delta = K.gamma#
#
a.0 = 1#
#b.0 = 10^{-6}#
#a.0 = 0.001#
b.0 = 0.0001#
Lambda.beta.0 = 1/1000*diag(p)#
# INITIALIZE:#
#mu.alpha.q = matrix(rep(0, n))#
#mu.beta.q = matrix(rep(0, p))#
mu.alpha.q = glmm$coefficients$random[[1]]#
mu.beta.q = glmm$coefficients$fixed#
mu.gamma.q = matrix(rep(0, r))#
mu.delta.q = matrix(rep(0, r))#
Sigma.gamma.q = diag(r)#
Sigma.delta.q = diag(r)#
b.gamma.q = b.0#
b.delta.q = b.0#
tr = function(X) sum(diag(X))#
# START:#
library(Matrix)#
#groups = as.matrix(bdiag(lapply(1:n, function(x) rep(1,ni[x]))))#
#
## Step 1:#
S.list = lapply(1:n, function(i) S[i,] %*% t(S[i,]))#
Sigma.beta.q = solve(t(X) %*% X + Lambda.beta.0)#
a.gamma.q = a.0 + ncol(K.gamma)/2#
a.delta.q = a.0 + ncol(K.delta)/2#
#
Xmu.beta.q = X %*% mu.beta.q#
tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
mu.Z.star = rep(0, N)#
new.mu.alpha.q = mu.alpha.q#
new.b.delta.q = b.delta.q#
epsilon = 10^(-5)#
L = NULL#
for(i in 1:10000){#
#
## Step 2: 0.128#
  mu.Z.q = rep(mu.alpha.q, ni) + Xmu.beta.q#
  numer = dnorm(-mu.Z.q)#
  denom = pnorm(-mu.Z.q)#
  mu.Z.star[Y == 1] = mu.Z.q[Y==1] + numer[Y == 1]/(1-denom[Y==1])#
  mu.Z.star[Y == 0] = mu.Z.q[Y==0] - numer[Y == 0]/denom[Y==0]#
#
  ## Step 3: 0.044#
  mu.beta.q = t(t(mu.Z.star - rep(mu.alpha.q,ni)) %*% X %*% Sigma.beta.q)#
  Xmu.beta.q = X %*% mu.beta.q#
#
  ## Step 4: 0.024#
  Sigma.alpha.q = matrix(1/(ni + tau.star))#
  mu.alpha.q = (rowsum(mu.Z.star - Xmu.beta.q, groups.index) + (S%*%mu.gamma.q)*tau.star) * Sigma.alpha.q#
  #mu.alpha.q = alpha#
  #Sigma.alpha.q = matrix(rep(1/1000, n))#
  ## Step 5: 0.000#
  E.resid = Sigma.alpha.q + mu.alpha.q^2 - 2*mu.alpha.q*(S %*% mu.gamma.q) + rowSums((S %*% (Sigma.gamma.q + mu.gamma.q %*% t(mu.gamma.q))) * S)#
  weighted.list = lapply(1:n, function(i) S.list[[i]]*E.resid[i]*tau.star[i])#
  Sigma.delta.q = solve(a.delta.q/b.delta.q * K.delta + 0.5*Reduce("+", S.list))#
  mu.delta.q = mu.delta.q + Sigma.delta.q %*% (-(a.delta.q/b.delta.q*K.delta)%*%mu.delta.q + 0.5*colSums(c(1-tau.star*E.resid)*S))#
  tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
#
  ## Step 6: 0.000#
  tau.starS = c(tau.star) * S#
  Sigma.gamma.q = solve(t(S) %*% tau.starS + a.gamma.q/b.gamma.q * K.gamma)#
  mu.gamma.q = t(t(mu.alpha.q) %*% tau.starS %*% Sigma.gamma.q)#
#
  ## Step 7:#
  #old.b.gamma.q = b.gamma.q#
  b.gamma.q = as.numeric(b.0 + 0.5*(tr(K.gamma %*% Sigma.gamma.q) + t(mu.gamma.q)%*%K.gamma%*%mu.gamma.q))#
  #b.gamma.q = 0.001#
  ## Step 8:#
  b.delta.q = as.numeric(b.0 + 0.5*(tr(K.delta %*% Sigma.delta.q) + t(mu.delta.q)%*%K.delta%*%mu.delta.q))#
  #b.delta.q = 0.001#
  old.mu.alpha.q = new.mu.alpha.q#
  new.mu.alpha.q = mu.alpha.q#
#
  old.b.delta.q = new.b.delta.q#
  new.b.delta.q = b.delta.q#
#
  #if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon && abs(a.delta.q/old.b.delta.q - a.delta.q/new.b.delta.q) < epsilon) break#
  if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon) break#
  #if(abs(old.b.gamma.q - b.gamma.q) < epsilon) break#
  cat(paste(i, "Beta error:   ", mean((mu.beta.q - beta)^2), "  "))#
  cat(paste("Alpha error:   ", mean((mu.alpha.q - alpha)^2), "\n"))#
  cat(paste("lambda.gamma:   ", a.gamma.q / b.gamma.q, "   lambda.delta:   ", a.delta.q / b.delta.q,  "\n"))#
  par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)#
}#
#
plot(mu.alpha.q~s)#
plot(alpha~s)
Run the algorithm:#
# PRIORS:#
nknots = 40#
groups.index = rep(1:n, ni)#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
#knots = quantile(s, seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = round(diff(range(s))/(nknots+1)*1:nknots)#
#knots = diff(range(s))/(nknots+1)*1:nknots#
#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2))#
#knots = quantile(s, seq(0, 1, length = nknots + 2))#
S = bs(s, intercept = TRUE, knots = knots)#
#S = ns(s, intercept = TRUE, knots = knots)#
#r = ncol(S)#
#bspl2.2 <- create.bspline.basis(norder=4, breaks= knots)#
#S <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S)#
#
## The goal with this fix is to reduce the wiggliness at the high-end#
## where only a few observations are given. It is reasonable to assume#
## that with only a few widely spread out observations, the line#
## through the data is the best option.#
library(ppls)#
K = Penalty.matrix(c(ncol(S)),2)#
diags <- list(rep(1, r), rep(-2, r), rep(1, r))#
A <- bandSparse(r, k = c(0:2), diag =diags, symm=FALSE)#
A = as.matrix(A)#
A[1:2, 1:2] = 0#
counts = apply(S, 2, function(x) sum(x > 0))#
counts = ifelse(counts == 0, 10^{-6}, counts)#
K.gamma = A %*% diag(1/counts) %*% t(A)#
K.delta = A %*% t(A)#
#K.delta = K.gamma#
#
a.0 = 1#
#b.0 = 10^{-6}#
#a.0 = 0.001#
b.0 = 0.0001#
Lambda.beta.0 = 1/1000*diag(p)#
# INITIALIZE:#
mu.alpha.q = matrix(rep(0, n))#
mu.beta.q = matrix(rep(0, p))#
#mu.alpha.q = glmm$coefficients$random[[1]]#
#mu.beta.q = glmm$coefficients$fixed#
mu.gamma.q = matrix(rep(0, r))#
mu.delta.q = matrix(rep(0, r))#
Sigma.gamma.q = diag(r)#
Sigma.delta.q = diag(r)#
b.gamma.q = b.0#
b.delta.q = b.0#
tr = function(X) sum(diag(X))#
# START:#
library(Matrix)#
#groups = as.matrix(bdiag(lapply(1:n, function(x) rep(1,ni[x]))))#
#
## Step 1:#
S.list = lapply(1:n, function(i) S[i,] %*% t(S[i,]))#
Sigma.beta.q = solve(t(X) %*% X + Lambda.beta.0)#
a.gamma.q = a.0 + ncol(K.gamma)/2#
a.delta.q = a.0 + ncol(K.delta)/2#
#
Xmu.beta.q = X %*% mu.beta.q#
tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
mu.Z.star = rep(0, N)#
new.mu.alpha.q = mu.alpha.q#
new.b.delta.q = b.delta.q#
epsilon = 10^(-5)#
L = NULL#
for(i in 1:10000){#
#
## Step 2: 0.128#
  mu.Z.q = rep(mu.alpha.q, ni) + Xmu.beta.q#
  numer = dnorm(-mu.Z.q)#
  denom = pnorm(-mu.Z.q)#
  mu.Z.star[Y == 1] = mu.Z.q[Y==1] + numer[Y == 1]/(1-denom[Y==1])#
  mu.Z.star[Y == 0] = mu.Z.q[Y==0] - numer[Y == 0]/denom[Y==0]#
#
  ## Step 3: 0.044#
  mu.beta.q = t(t(mu.Z.star - rep(mu.alpha.q,ni)) %*% X %*% Sigma.beta.q)#
  Xmu.beta.q = X %*% mu.beta.q#
#
  ## Step 4: 0.024#
  Sigma.alpha.q = matrix(1/(ni + tau.star))#
  mu.alpha.q = (rowsum(mu.Z.star - Xmu.beta.q, groups.index) + (S%*%mu.gamma.q)*tau.star) * Sigma.alpha.q#
  #mu.alpha.q = alpha#
  #Sigma.alpha.q = matrix(rep(1/1000, n))#
  ## Step 5: 0.000#
  E.resid = Sigma.alpha.q + mu.alpha.q^2 - 2*mu.alpha.q*(S %*% mu.gamma.q) + rowSums((S %*% (Sigma.gamma.q + mu.gamma.q %*% t(mu.gamma.q))) * S)#
  weighted.list = lapply(1:n, function(i) S.list[[i]]*E.resid[i]*tau.star[i])#
  Sigma.delta.q = solve(a.delta.q/b.delta.q * K.delta + 0.5*Reduce("+", S.list))#
  mu.delta.q = mu.delta.q + Sigma.delta.q %*% (-(a.delta.q/b.delta.q*K.delta)%*%mu.delta.q + 0.5*colSums(c(1-tau.star*E.resid)*S))#
  tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
#
  ## Step 6: 0.000#
  tau.starS = c(tau.star) * S#
  Sigma.gamma.q = solve(t(S) %*% tau.starS + a.gamma.q/b.gamma.q * K.gamma)#
  mu.gamma.q = t(t(mu.alpha.q) %*% tau.starS %*% Sigma.gamma.q)#
#
  ## Step 7:#
  #old.b.gamma.q = b.gamma.q#
  b.gamma.q = as.numeric(b.0 + 0.5*(tr(K.gamma %*% Sigma.gamma.q) + t(mu.gamma.q)%*%K.gamma%*%mu.gamma.q))#
  #b.gamma.q = 0.001#
  ## Step 8:#
  b.delta.q = as.numeric(b.0 + 0.5*(tr(K.delta %*% Sigma.delta.q) + t(mu.delta.q)%*%K.delta%*%mu.delta.q))#
  #b.delta.q = 0.001#
  old.mu.alpha.q = new.mu.alpha.q#
  new.mu.alpha.q = mu.alpha.q#
#
  old.b.delta.q = new.b.delta.q#
  new.b.delta.q = b.delta.q#
#
  #if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon && abs(a.delta.q/old.b.delta.q - a.delta.q/new.b.delta.q) < epsilon) break#
  if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon) break#
  #if(abs(old.b.gamma.q - b.gamma.q) < epsilon) break#
  cat(paste(i, "Beta error:   ", mean((mu.beta.q - beta)^2), "  "))#
  cat(paste("Alpha error:   ", mean((mu.alpha.q - alpha)^2), "\n"))#
  cat(paste("lambda.gamma:   ", a.gamma.q / b.gamma.q, "   lambda.delta:   ", a.delta.q / b.delta.q,  "\n"))#
  par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)#
}#
#
plot(mu.alpha.q~s)#
plot(alpha~s)
n = 4300#
#n = 2000#
cluster.size = 100#
p = 27#
#
#ni = rep(cluster.size, n)#
#ni = round(runif(n, 1, 100))#
#ni = sort(round(rgamma(n, 2, 20)*1000)+1)#
ni = sort(round(rexp(n, 1)*100)+1)#
N = sum(ni)#
#
library(splines)#
#s = runif(n, 0, 2)*1:n/n#
#s = rep(ni,ni)#
#s = scale(ni)#
#s = scale(s)#
s = ni#
nknots = 4#
##S = bs(s, intercept = TRUE, degree = 3, df = 3+1+nknots)#
#S.true = ns(s, intercept = TRUE, df = 3+1+nknots)#
#knots = unique(s)#
#S = ns(s, intercept = TRUE, knots = knots)#
#
library(fda)#
bspl2.2 <- create.bspline.basis(norder=4, breaks= quantile(s))#
S.true <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S.true)#
#
#S.true = cbind(1, s)#
#
gamma = c(-0.3,-0.4, -0.2, -1, -0.5, -1, -1.2)#
                                        #gamma = c(-0.5, -0.001)#
plot( S.true %*% gamma~s)#
#delta = c(-0.2,0.2,0.3, 0.3, 1.2, 2, 2)#
delta = c(1,1,1, 1, 1.2, 2, 2)#
#
                                        #delta = c(0.1, 0.01)#
plot( exp(-S.true %*% delta)~s)#
alpha = rnorm(n, S.true %*% gamma, sqrt(exp(-S.true %*% delta))) #
alpha.rep = rep(alpha, ni)#
plot(alpha~s)#
#
# In our model, X cannot have an intercept term. This makes the model#
# non-identifiable. Also, be careful with the simulated structure of#
# the predictors.#
X = sapply(1:p, function(x) runif(N, -1, 1)*1:N/N)#
#X = sapply(1:p, function(x) runif(N, -1, 1)*1:N/N)#
#X = rep(1:cluster.size/cluster.size, n)#
#X = cbind(rep(-(cluster.size:1)/cluster.size, n), X)#
beta = sample(c(-1,1), p, replace = TRUE)*(1:p)/p#
eta = alpha.rep + X %*% beta#
probs = pnorm(eta)#
Y = sapply(1:N, function(x) rbinom(1,1,probs[x]))
Run the algorithm:#
# PRIORS:#
nknots = 40#
groups.index = rep(1:n, ni)#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
#knots = quantile(s, seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = round(diff(range(s))/(nknots+1)*1:nknots)#
#knots = diff(range(s))/(nknots+1)*1:nknots#
#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2))#
#knots = quantile(s, seq(0, 1, length = nknots + 2))#
S = bs(s, intercept = TRUE, knots = knots)#
#S = ns(s, intercept = TRUE, knots = knots)#
#r = ncol(S)#
#bspl2.2 <- create.bspline.basis(norder=4, breaks= knots)#
#S <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S)#
#
## The goal with this fix is to reduce the wiggliness at the high-end#
## where only a few observations are given. It is reasonable to assume#
## that with only a few widely spread out observations, the line#
## through the data is the best option.#
library(ppls)#
K = Penalty.matrix(c(ncol(S)),2)#
diags <- list(rep(1, r), rep(-2, r), rep(1, r))#
A <- bandSparse(r, k = c(0:2), diag =diags, symm=FALSE)#
A = as.matrix(A)#
A[1:2, 1:2] = 0#
counts = apply(S, 2, function(x) sum(x > 0))#
counts = ifelse(counts == 0, 10^{-6}, counts)#
K.gamma = A %*% diag(1/counts) %*% t(A)#
K.delta = A %*% t(A)#
#K.delta = K.gamma#
#
a.0 = 1#
#b.0 = 10^{-6}#
#a.0 = 0.001#
b.0 = 0.0001#
Lambda.beta.0 = 1/1000*diag(p)#
# INITIALIZE:#
mu.alpha.q = matrix(rep(0, n))#
mu.beta.q = matrix(rep(0, p))#
#mu.alpha.q = glmm$coefficients$random[[1]]#
#mu.beta.q = glmm$coefficients$fixed#
mu.gamma.q = matrix(rep(0, r))#
mu.delta.q = matrix(rep(0, r))#
Sigma.gamma.q = diag(r)#
Sigma.delta.q = diag(r)#
b.gamma.q = b.0#
b.delta.q = b.0#
tr = function(X) sum(diag(X))#
# START:#
library(Matrix)#
#groups = as.matrix(bdiag(lapply(1:n, function(x) rep(1,ni[x]))))#
#
## Step 1:#
S.list = lapply(1:n, function(i) S[i,] %*% t(S[i,]))#
Sigma.beta.q = solve(t(X) %*% X + Lambda.beta.0)#
a.gamma.q = a.0 + ncol(K.gamma)/2#
a.delta.q = a.0 + ncol(K.delta)/2#
#
Xmu.beta.q = X %*% mu.beta.q#
tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
mu.Z.star = rep(0, N)#
new.mu.alpha.q = mu.alpha.q#
new.b.delta.q = b.delta.q#
epsilon = 10^(-5)#
L = NULL#
for(i in 1:10000){#
#
## Step 2: 0.128#
  mu.Z.q = rep(mu.alpha.q, ni) + Xmu.beta.q#
  numer = dnorm(-mu.Z.q)#
  denom = pnorm(-mu.Z.q)#
  mu.Z.star[Y == 1] = mu.Z.q[Y==1] + numer[Y == 1]/(1-denom[Y==1])#
  mu.Z.star[Y == 0] = mu.Z.q[Y==0] - numer[Y == 0]/denom[Y==0]#
#
  ## Step 3: 0.044#
  mu.beta.q = t(t(mu.Z.star - rep(mu.alpha.q,ni)) %*% X %*% Sigma.beta.q)#
  Xmu.beta.q = X %*% mu.beta.q#
#
  ## Step 4: 0.024#
  Sigma.alpha.q = matrix(1/(ni + tau.star))#
  mu.alpha.q = (rowsum(mu.Z.star - Xmu.beta.q, groups.index) + (S%*%mu.gamma.q)*tau.star) * Sigma.alpha.q#
  #mu.alpha.q = alpha#
  #Sigma.alpha.q = matrix(rep(1/1000, n))#
  ## Step 5: 0.000#
  E.resid = Sigma.alpha.q + mu.alpha.q^2 - 2*mu.alpha.q*(S %*% mu.gamma.q) + rowSums((S %*% (Sigma.gamma.q + mu.gamma.q %*% t(mu.gamma.q))) * S)#
  weighted.list = lapply(1:n, function(i) S.list[[i]]*E.resid[i]*tau.star[i])#
  Sigma.delta.q = solve(a.delta.q/b.delta.q * K.delta + 0.5*Reduce("+", S.list))#
  mu.delta.q = mu.delta.q + Sigma.delta.q %*% (-(a.delta.q/b.delta.q*K.delta)%*%mu.delta.q + 0.5*colSums(c(1-tau.star*E.resid)*S))#
  tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
#
  ## Step 6: 0.000#
  tau.starS = c(tau.star) * S#
  Sigma.gamma.q = solve(t(S) %*% tau.starS + a.gamma.q/b.gamma.q * K.gamma)#
  mu.gamma.q = t(t(mu.alpha.q) %*% tau.starS %*% Sigma.gamma.q)#
#
  ## Step 7:#
  #old.b.gamma.q = b.gamma.q#
  b.gamma.q = as.numeric(b.0 + 0.5*(tr(K.gamma %*% Sigma.gamma.q) + t(mu.gamma.q)%*%K.gamma%*%mu.gamma.q))#
  #b.gamma.q = 0.001#
  ## Step 8:#
  b.delta.q = as.numeric(b.0 + 0.5*(tr(K.delta %*% Sigma.delta.q) + t(mu.delta.q)%*%K.delta%*%mu.delta.q))#
  #b.delta.q = 0.001#
  old.mu.alpha.q = new.mu.alpha.q#
  new.mu.alpha.q = mu.alpha.q#
#
  old.b.delta.q = new.b.delta.q#
  new.b.delta.q = b.delta.q#
#
  #if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon && abs(a.delta.q/old.b.delta.q - a.delta.q/new.b.delta.q) < epsilon) break#
  if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon) break#
  #if(abs(old.b.gamma.q - b.gamma.q) < epsilon) break#
  cat(paste(i, "Beta error:   ", mean((mu.beta.q - beta)^2), "  "))#
  cat(paste("Alpha error:   ", mean((mu.alpha.q - alpha)^2), "\n"))#
  cat(paste("lambda.gamma:   ", a.gamma.q / b.gamma.q, "   lambda.delta:   ", a.delta.q / b.delta.q,  "\n"))#
  par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)#
}#
#
plot(mu.alpha.q~s)#
plot(alpha~s)
Run the algorithm:#
# PRIORS:#
nknots = 20#
groups.index = rep(1:n, ni)#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
#knots = quantile(s, seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = round(diff(range(s))/(nknots+1)*1:nknots)#
#knots = diff(range(s))/(nknots+1)*1:nknots#
#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2))#
#knots = quantile(s, seq(0, 1, length = nknots + 2))#
S = bs(s, intercept = TRUE, knots = knots)#
#S = ns(s, intercept = TRUE, knots = knots)#
#r = ncol(S)#
#bspl2.2 <- create.bspline.basis(norder=4, breaks= knots)#
#S <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S)#
#
## The goal with this fix is to reduce the wiggliness at the high-end#
## where only a few observations are given. It is reasonable to assume#
## that with only a few widely spread out observations, the line#
## through the data is the best option.#
library(ppls)#
K = Penalty.matrix(c(ncol(S)),2)#
diags <- list(rep(1, r), rep(-2, r), rep(1, r))#
A <- bandSparse(r, k = c(0:2), diag =diags, symm=FALSE)#
A = as.matrix(A)#
A[1:2, 1:2] = 0#
counts = apply(S, 2, function(x) sum(x > 0))#
counts = ifelse(counts == 0, 10^{-6}, counts)#
K.gamma = A %*% diag(1/counts) %*% t(A)#
K.delta = A %*% t(A)#
#K.delta = K.gamma#
#
a.0 = 1#
#b.0 = 10^{-6}#
#a.0 = 0.001#
b.0 = 0.0001#
Lambda.beta.0 = 1/1000*diag(p)#
# INITIALIZE:#
mu.alpha.q = matrix(rep(0, n))#
mu.beta.q = matrix(rep(0, p))#
#mu.alpha.q = glmm$coefficients$random[[1]]#
#mu.beta.q = glmm$coefficients$fixed#
mu.gamma.q = matrix(rep(0, r))#
mu.delta.q = matrix(rep(0, r))#
Sigma.gamma.q = diag(r)#
Sigma.delta.q = diag(r)#
b.gamma.q = b.0#
b.delta.q = b.0#
tr = function(X) sum(diag(X))#
# START:#
library(Matrix)#
#groups = as.matrix(bdiag(lapply(1:n, function(x) rep(1,ni[x]))))#
#
## Step 1:#
S.list = lapply(1:n, function(i) S[i,] %*% t(S[i,]))#
Sigma.beta.q = solve(t(X) %*% X + Lambda.beta.0)#
a.gamma.q = a.0 + ncol(K.gamma)/2#
a.delta.q = a.0 + ncol(K.delta)/2#
#
Xmu.beta.q = X %*% mu.beta.q#
tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
mu.Z.star = rep(0, N)#
new.mu.alpha.q = mu.alpha.q#
new.b.delta.q = b.delta.q#
epsilon = 10^(-5)#
L = NULL#
for(i in 1:10000){#
#
## Step 2: 0.128#
  mu.Z.q = rep(mu.alpha.q, ni) + Xmu.beta.q#
  numer = dnorm(-mu.Z.q)#
  denom = pnorm(-mu.Z.q)#
  mu.Z.star[Y == 1] = mu.Z.q[Y==1] + numer[Y == 1]/(1-denom[Y==1])#
  mu.Z.star[Y == 0] = mu.Z.q[Y==0] - numer[Y == 0]/denom[Y==0]#
#
  ## Step 3: 0.044#
  mu.beta.q = t(t(mu.Z.star - rep(mu.alpha.q,ni)) %*% X %*% Sigma.beta.q)#
  Xmu.beta.q = X %*% mu.beta.q#
#
  ## Step 4: 0.024#
  Sigma.alpha.q = matrix(1/(ni + tau.star))#
  mu.alpha.q = (rowsum(mu.Z.star - Xmu.beta.q, groups.index) + (S%*%mu.gamma.q)*tau.star) * Sigma.alpha.q#
  #mu.alpha.q = alpha#
  #Sigma.alpha.q = matrix(rep(1/1000, n))#
  ## Step 5: 0.000#
  E.resid = Sigma.alpha.q + mu.alpha.q^2 - 2*mu.alpha.q*(S %*% mu.gamma.q) + rowSums((S %*% (Sigma.gamma.q + mu.gamma.q %*% t(mu.gamma.q))) * S)#
  weighted.list = lapply(1:n, function(i) S.list[[i]]*E.resid[i]*tau.star[i])#
  Sigma.delta.q = solve(a.delta.q/b.delta.q * K.delta + 0.5*Reduce("+", S.list))#
  mu.delta.q = mu.delta.q + Sigma.delta.q %*% (-(a.delta.q/b.delta.q*K.delta)%*%mu.delta.q + 0.5*colSums(c(1-tau.star*E.resid)*S))#
  tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
#
  ## Step 6: 0.000#
  tau.starS = c(tau.star) * S#
  Sigma.gamma.q = solve(t(S) %*% tau.starS + a.gamma.q/b.gamma.q * K.gamma)#
  mu.gamma.q = t(t(mu.alpha.q) %*% tau.starS %*% Sigma.gamma.q)#
#
  ## Step 7:#
  #old.b.gamma.q = b.gamma.q#
  b.gamma.q = as.numeric(b.0 + 0.5*(tr(K.gamma %*% Sigma.gamma.q) + t(mu.gamma.q)%*%K.gamma%*%mu.gamma.q))#
  #b.gamma.q = 0.001#
  ## Step 8:#
  b.delta.q = as.numeric(b.0 + 0.5*(tr(K.delta %*% Sigma.delta.q) + t(mu.delta.q)%*%K.delta%*%mu.delta.q))#
  #b.delta.q = 0.001#
  old.mu.alpha.q = new.mu.alpha.q#
  new.mu.alpha.q = mu.alpha.q#
#
  old.b.delta.q = new.b.delta.q#
  new.b.delta.q = b.delta.q#
#
  #if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon && abs(a.delta.q/old.b.delta.q - a.delta.q/new.b.delta.q) < epsilon) break#
  if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon) break#
  #if(abs(old.b.gamma.q - b.gamma.q) < epsilon) break#
  cat(paste(i, "Beta error:   ", mean((mu.beta.q - beta)^2), "  "))#
  cat(paste("Alpha error:   ", mean((mu.alpha.q - alpha)^2), "\n"))#
  cat(paste("lambda.gamma:   ", a.gamma.q / b.gamma.q, "   lambda.delta:   ", a.delta.q / b.delta.q,  "\n"))#
  par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)#
}#
#
plot(mu.alpha.q~s)#
plot(alpha~s)
gamma = c(-0.3,-0.4, -0.2, -1, -0.5, -1, -1.2)#
                                        #gamma = c(-0.5, -0.001)#
plot( S.true %*% gamma~s)
gamma = c(-0.3,-0, -0.2, -1, -0.5, -1, -1.2)#
                                        #gamma = c(-0.5, -0.001)#
plot( S.true %*% gamma~s)
gamma = c(0,-0, -0.2, -1, -0.5, -1, -1.2)#
                                        #gamma = c(-0.5, -0.001)#
plot( S.true %*% gamma~s)
gamma = c(0, -0.1, -0.3, -1, -0.5, -1, -1.2)#
                                        #gamma = c(-0.5, -0.001)#
plot( S.true %*% gamma~s)
gamma = c(0, -0.1, -0.3, -3, -0.5, -1, -1.2)#
                                        #gamma = c(-0.5, -0.001)#
plot( S.true %*% gamma~s)
gamma = c(0, -0.1, -0.3, -0.4, -0.5, -1, -1.2)#
                                        #gamma = c(-0.5, -0.001)#
plot( S.true %*% gamma~s)
delta = c(-0.2,0.2,0.3, 0.3, 1.2, 2, 2)#
delta = c(1,1,1, 1, 1.2, 2, 2)#
#
                                        #delta = c(0.1, 0.01)#
plot( exp(-S.true %*% delta)~s)
Simulate data:#
n = 4300#
#n = 2000#
cluster.size = 100#
p = 27#
#
#ni = rep(cluster.size, n)#
#ni = round(runif(n, 1, 100))#
#ni = sort(round(rgamma(n, 2, 20)*1000)+1)#
ni = sort(round(rexp(n, 1)*100)+1)#
N = sum(ni)#
#
library(splines)#
#s = runif(n, 0, 2)*1:n/n#
#s = rep(ni,ni)#
#s = scale(ni)#
#s = scale(s)#
s = ni#
nknots = 4#
##S = bs(s, intercept = TRUE, degree = 3, df = 3+1+nknots)#
#S.true = ns(s, intercept = TRUE, df = 3+1+nknots)#
#knots = unique(s)#
#S = ns(s, intercept = TRUE, knots = knots)#
#
library(fda)#
bspl2.2 <- create.bspline.basis(norder=4, breaks= quantile(s))#
S.true <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S.true)#
#
#S.true = cbind(1, s)#
#
#gamma = c(-0.3,-0.4, -0.2, -1, -0.5, -1, -1.2)#
gamma = c(0, -0.1, -0.3, -0.4, -0.5, -1, -1.2)#
                                        #gamma = c(-0.5, -0.001)#
plot( S.true %*% gamma~s)#
#delta = c(-0.2,0.2,0.3, 0.3, 1.2, 2, 2)#
delta = c(1,1,1, 1, 1.2, 2, 2)#
#
                                        #delta = c(0.1, 0.01)#
plot( exp(-S.true %*% delta)~s)#
alpha = rnorm(n, S.true %*% gamma, sqrt(exp(-S.true %*% delta))) #
alpha.rep = rep(alpha, ni)#
plot(alpha~s)#
#
# In our model, X cannot have an intercept term. This makes the model#
# non-identifiable. Also, be careful with the simulated structure of#
# the predictors.#
X = sapply(1:p, function(x) runif(N, -1, 1)*1:N/N)#
#X = sapply(1:p, function(x) runif(N, -1, 1)*1:N/N)#
#X = rep(1:cluster.size/cluster.size, n)#
#X = cbind(rep(-(cluster.size:1)/cluster.size, n), X)#
beta = sample(c(-1,1), p, replace = TRUE)*(1:p)/p#
eta = alpha.rep + X %*% beta#
probs = pnorm(eta)#
Y = sapply(1:N, function(x) rbinom(1,1,probs[x]))#
#
#library(MASS)#
#dd = data.frame(Y,X)#
#ID = rep(1:n,ni)#
#glmm = glmmPQL(Y~-1+X1+X2+X3+X4+X5+X6+X7+X8+X9+X10+X11+X12+X13+X14+X15+X16+X17+X18+X19+X20+X21+X22+X23+X24+X25+X26+X27, random  = ~1 | ID,family = binomial, data = dd)#
##########################################################################################################
## Run the algorithm:#
# PRIORS:#
nknots = 20#
groups.index = rep(1:n, ni)#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
#knots = quantile(s, seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = round(diff(range(s))/(nknots+1)*1:nknots)#
#knots = diff(range(s))/(nknots+1)*1:nknots#
#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2))#
#knots = quantile(s, seq(0, 1, length = nknots + 2))#
S = bs(s, intercept = TRUE, knots = knots)#
#S = ns(s, intercept = TRUE, knots = knots)#
#r = ncol(S)#
#bspl2.2 <- create.bspline.basis(norder=4, breaks= knots)#
#S <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S)#
#
## The goal with this fix is to reduce the wiggliness at the high-end#
## where only a few observations are given. It is reasonable to assume#
## that with only a few widely spread out observations, the line#
## through the data is the best option.#
library(ppls)#
K = Penalty.matrix(c(ncol(S)),2)#
diags <- list(rep(1, r), rep(-2, r), rep(1, r))#
A <- bandSparse(r, k = c(0:2), diag =diags, symm=FALSE)#
A = as.matrix(A)#
A[1:2, 1:2] = 0#
counts = apply(S, 2, function(x) sum(x > 0))#
counts = ifelse(counts == 0, 10^{-6}, counts)#
K.gamma = A %*% diag(1/counts) %*% t(A)#
K.delta = A %*% t(A)#
#K.delta = K.gamma#
#
a.0 = 1#
#b.0 = 10^{-6}#
#a.0 = 0.001#
b.0 = 0.0001#
Lambda.beta.0 = 1/1000*diag(p)#
# INITIALIZE:#
mu.alpha.q = matrix(rep(0, n))#
mu.beta.q = matrix(rep(0, p))#
#mu.alpha.q = glmm$coefficients$random[[1]]#
#mu.beta.q = glmm$coefficients$fixed#
mu.gamma.q = matrix(rep(0, r))#
mu.delta.q = matrix(rep(0, r))#
Sigma.gamma.q = diag(r)#
Sigma.delta.q = diag(r)#
b.gamma.q = b.0#
b.delta.q = b.0#
tr = function(X) sum(diag(X))#
# START:#
library(Matrix)#
#groups = as.matrix(bdiag(lapply(1:n, function(x) rep(1,ni[x]))))#
#
## Step 1:#
S.list = lapply(1:n, function(i) S[i,] %*% t(S[i,]))#
Sigma.beta.q = solve(t(X) %*% X + Lambda.beta.0)#
a.gamma.q = a.0 + ncol(K.gamma)/2#
a.delta.q = a.0 + ncol(K.delta)/2#
#
Xmu.beta.q = X %*% mu.beta.q#
tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
mu.Z.star = rep(0, N)#
new.mu.alpha.q = mu.alpha.q#
new.b.delta.q = b.delta.q#
epsilon = 10^(-5)#
L = NULL#
for(i in 1:10000){#
#
## Step 2: 0.128#
  mu.Z.q = rep(mu.alpha.q, ni) + Xmu.beta.q#
  numer = dnorm(-mu.Z.q)#
  denom = pnorm(-mu.Z.q)#
  mu.Z.star[Y == 1] = mu.Z.q[Y==1] + numer[Y == 1]/(1-denom[Y==1])#
  mu.Z.star[Y == 0] = mu.Z.q[Y==0] - numer[Y == 0]/denom[Y==0]#
#
  ## Step 3: 0.044#
  mu.beta.q = t(t(mu.Z.star - rep(mu.alpha.q,ni)) %*% X %*% Sigma.beta.q)#
  Xmu.beta.q = X %*% mu.beta.q#
#
  ## Step 4: 0.024#
  Sigma.alpha.q = matrix(1/(ni + tau.star))#
  mu.alpha.q = (rowsum(mu.Z.star - Xmu.beta.q, groups.index) + (S%*%mu.gamma.q)*tau.star) * Sigma.alpha.q#
  #mu.alpha.q = alpha#
  #Sigma.alpha.q = matrix(rep(1/1000, n))#
  ## Step 5: 0.000#
  E.resid = Sigma.alpha.q + mu.alpha.q^2 - 2*mu.alpha.q*(S %*% mu.gamma.q) + rowSums((S %*% (Sigma.gamma.q + mu.gamma.q %*% t(mu.gamma.q))) * S)#
  weighted.list = lapply(1:n, function(i) S.list[[i]]*E.resid[i]*tau.star[i])#
  Sigma.delta.q = solve(a.delta.q/b.delta.q * K.delta + 0.5*Reduce("+", S.list))#
  mu.delta.q = mu.delta.q + Sigma.delta.q %*% (-(a.delta.q/b.delta.q*K.delta)%*%mu.delta.q + 0.5*colSums(c(1-tau.star*E.resid)*S))#
  tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
#
  ## Step 6: 0.000#
  tau.starS = c(tau.star) * S#
  Sigma.gamma.q = solve(t(S) %*% tau.starS + a.gamma.q/b.gamma.q * K.gamma)#
  mu.gamma.q = t(t(mu.alpha.q) %*% tau.starS %*% Sigma.gamma.q)#
#
  ## Step 7:#
  #old.b.gamma.q = b.gamma.q#
  b.gamma.q = as.numeric(b.0 + 0.5*(tr(K.gamma %*% Sigma.gamma.q) + t(mu.gamma.q)%*%K.gamma%*%mu.gamma.q))#
  #b.gamma.q = 0.001#
  ## Step 8:#
  b.delta.q = as.numeric(b.0 + 0.5*(tr(K.delta %*% Sigma.delta.q) + t(mu.delta.q)%*%K.delta%*%mu.delta.q))#
  #b.delta.q = 0.001#
  old.mu.alpha.q = new.mu.alpha.q#
  new.mu.alpha.q = mu.alpha.q#
#
  old.b.delta.q = new.b.delta.q#
  new.b.delta.q = b.delta.q#
#
  #if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon && abs(a.delta.q/old.b.delta.q - a.delta.q/new.b.delta.q) < epsilon) break#
  if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon) break#
  #if(abs(old.b.gamma.q - b.gamma.q) < epsilon) break#
  cat(paste(i, "Beta error:   ", mean((mu.beta.q - beta)^2), "  "))#
  cat(paste("Alpha error:   ", mean((mu.alpha.q - alpha)^2), "\n"))#
  cat(paste("lambda.gamma:   ", a.gamma.q / b.gamma.q, "   lambda.delta:   ", a.delta.q / b.delta.q,  "\n"))#
  par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)#
}#
#
plot(mu.alpha.q~s)#
plot(alpha~s)
par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)
plot(mu.alpha.q~s)#
plot(alpha~s)
par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)
Run the algorithm:#
# PRIORS:#
nknots = 20#
groups.index = rep(1:n, ni)#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
#knots = quantile(s, seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = round(diff(range(s))/(nknots+1)*1:nknots)#
#knots = diff(range(s))/(nknots+1)*1:nknots#
#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2))#
#knots = quantile(s, seq(0, 1, length = nknots + 2))#
S = bs(s, intercept = TRUE, knots = knots)#
#S = ns(s, intercept = TRUE, knots = knots)#
#r = ncol(S)#
#bspl2.2 <- create.bspline.basis(norder=4, breaks= knots)#
#S <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S)#
#
## The goal with this fix is to reduce the wiggliness at the high-end#
## where only a few observations are given. It is reasonable to assume#
## that with only a few widely spread out observations, the line#
## through the data is the best option.#
library(ppls)#
K = Penalty.matrix(c(ncol(S)),2)#
diags <- list(rep(1, r), rep(-2, r), rep(1, r))#
A <- bandSparse(r, k = c(0:2), diag =diags, symm=FALSE)#
A = as.matrix(A)#
A[1:2, 1:2] = 0#
counts = apply(S, 2, function(x) sum(x > 0))#
counts = ifelse(counts == 0, 10^{-6}, counts)#
K.gamma = A %*% diag(1/counts) %*% t(A)#
K.delta = A %*% t(A)#
K.delta = K.gamma#
#
a.0 = 1#
#b.0 = 10^{-6}#
#a.0 = 0.001#
b.0 = 0.0001#
Lambda.beta.0 = 1/1000*diag(p)#
# INITIALIZE:#
mu.alpha.q = matrix(rep(0, n))#
mu.beta.q = matrix(rep(0, p))#
#mu.alpha.q = glmm$coefficients$random[[1]]#
#mu.beta.q = glmm$coefficients$fixed#
mu.gamma.q = matrix(rep(0, r))#
mu.delta.q = matrix(rep(0, r))#
Sigma.gamma.q = diag(r)#
Sigma.delta.q = diag(r)#
b.gamma.q = b.0#
b.delta.q = b.0#
tr = function(X) sum(diag(X))#
# START:#
library(Matrix)#
#groups = as.matrix(bdiag(lapply(1:n, function(x) rep(1,ni[x]))))#
#
## Step 1:#
S.list = lapply(1:n, function(i) S[i,] %*% t(S[i,]))#
Sigma.beta.q = solve(t(X) %*% X + Lambda.beta.0)#
a.gamma.q = a.0 + ncol(K.gamma)/2#
a.delta.q = a.0 + ncol(K.delta)/2#
#
Xmu.beta.q = X %*% mu.beta.q#
tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
mu.Z.star = rep(0, N)#
new.mu.alpha.q = mu.alpha.q#
new.b.delta.q = b.delta.q#
epsilon = 10^(-5)#
L = NULL#
for(i in 1:10000){#
#
## Step 2: 0.128#
  mu.Z.q = rep(mu.alpha.q, ni) + Xmu.beta.q#
  numer = dnorm(-mu.Z.q)#
  denom = pnorm(-mu.Z.q)#
  mu.Z.star[Y == 1] = mu.Z.q[Y==1] + numer[Y == 1]/(1-denom[Y==1])#
  mu.Z.star[Y == 0] = mu.Z.q[Y==0] - numer[Y == 0]/denom[Y==0]#
#
  ## Step 3: 0.044#
  mu.beta.q = t(t(mu.Z.star - rep(mu.alpha.q,ni)) %*% X %*% Sigma.beta.q)#
  Xmu.beta.q = X %*% mu.beta.q#
#
  ## Step 4: 0.024#
  Sigma.alpha.q = matrix(1/(ni + tau.star))#
  mu.alpha.q = (rowsum(mu.Z.star - Xmu.beta.q, groups.index) + (S%*%mu.gamma.q)*tau.star) * Sigma.alpha.q#
  #mu.alpha.q = alpha#
  #Sigma.alpha.q = matrix(rep(1/1000, n))#
  ## Step 5: 0.000#
  E.resid = Sigma.alpha.q + mu.alpha.q^2 - 2*mu.alpha.q*(S %*% mu.gamma.q) + rowSums((S %*% (Sigma.gamma.q + mu.gamma.q %*% t(mu.gamma.q))) * S)#
  weighted.list = lapply(1:n, function(i) S.list[[i]]*E.resid[i]*tau.star[i])#
  Sigma.delta.q = solve(a.delta.q/b.delta.q * K.delta + 0.5*Reduce("+", S.list))#
  mu.delta.q = mu.delta.q + Sigma.delta.q %*% (-(a.delta.q/b.delta.q*K.delta)%*%mu.delta.q + 0.5*colSums(c(1-tau.star*E.resid)*S))#
  tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
#
  ## Step 6: 0.000#
  tau.starS = c(tau.star) * S#
  Sigma.gamma.q = solve(t(S) %*% tau.starS + a.gamma.q/b.gamma.q * K.gamma)#
  mu.gamma.q = t(t(mu.alpha.q) %*% tau.starS %*% Sigma.gamma.q)#
#
  ## Step 7:#
  #old.b.gamma.q = b.gamma.q#
  b.gamma.q = as.numeric(b.0 + 0.5*(tr(K.gamma %*% Sigma.gamma.q) + t(mu.gamma.q)%*%K.gamma%*%mu.gamma.q))#
  #b.gamma.q = 0.001#
  ## Step 8:#
  b.delta.q = as.numeric(b.0 + 0.5*(tr(K.delta %*% Sigma.delta.q) + t(mu.delta.q)%*%K.delta%*%mu.delta.q))#
  #b.delta.q = 0.001#
  old.mu.alpha.q = new.mu.alpha.q#
  new.mu.alpha.q = mu.alpha.q#
#
  old.b.delta.q = new.b.delta.q#
  new.b.delta.q = b.delta.q#
#
  #if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon && abs(a.delta.q/old.b.delta.q - a.delta.q/new.b.delta.q) < epsilon) break#
  if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon) break#
  #if(abs(old.b.gamma.q - b.gamma.q) < epsilon) break#
  cat(paste(i, "Beta error:   ", mean((mu.beta.q - beta)^2), "  "))#
  cat(paste("Alpha error:   ", mean((mu.alpha.q - alpha)^2), "\n"))#
  cat(paste("lambda.gamma:   ", a.gamma.q / b.gamma.q, "   lambda.delta:   ", a.delta.q / b.delta.q,  "\n"))#
  par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)#
}#
#
plot(mu.alpha.q~s)#
plot(alpha~s)
Run the algorithm:#
# PRIORS:#
nknots = 20#
groups.index = rep(1:n, ni)#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
#knots = quantile(s, seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = round(diff(range(s))/(nknots+1)*1:nknots)#
#knots = diff(range(s))/(nknots+1)*1:nknots#
#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2))#
#knots = quantile(s, seq(0, 1, length = nknots + 2))#
S = bs(s, intercept = TRUE, knots = knots)#
#S = ns(s, intercept = TRUE, knots = knots)#
#r = ncol(S)#
#bspl2.2 <- create.bspline.basis(norder=4, breaks= knots)#
#S <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S)#
#
## The goal with this fix is to reduce the wiggliness at the high-end#
## where only a few observations are given. It is reasonable to assume#
## that with only a few widely spread out observations, the line#
## through the data is the best option.#
library(ppls)#
K = Penalty.matrix(c(ncol(S)),2)#
diags <- list(rep(1, r), rep(-2, r), rep(1, r))#
A <- bandSparse(r, k = c(0:2), diag =diags, symm=FALSE)#
A = as.matrix(A)#
A[1:2, 1:2] = 0#
counts = apply(S, 2, function(x) sum(x > 0))#
counts = ifelse(counts == 0, 10^{-6}, counts)#
#K.gamma = A %*% diag(1/counts) %*% t(A)#
K.gamma = A %*% t(A)#
K.delta = A %*% t(A)#
#K.delta = K.gamma#
#
a.0 = 1#
#b.0 = 10^{-6}#
#a.0 = 0.001#
b.0 = 0.0001#
Lambda.beta.0 = 1/1000*diag(p)#
# INITIALIZE:#
mu.alpha.q = matrix(rep(0, n))#
mu.beta.q = matrix(rep(0, p))#
#mu.alpha.q = glmm$coefficients$random[[1]]#
#mu.beta.q = glmm$coefficients$fixed#
mu.gamma.q = matrix(rep(0, r))#
mu.delta.q = matrix(rep(0, r))#
Sigma.gamma.q = diag(r)#
Sigma.delta.q = diag(r)#
b.gamma.q = b.0#
b.delta.q = b.0#
tr = function(X) sum(diag(X))#
# START:#
library(Matrix)#
#groups = as.matrix(bdiag(lapply(1:n, function(x) rep(1,ni[x]))))#
#
## Step 1:#
S.list = lapply(1:n, function(i) S[i,] %*% t(S[i,]))#
Sigma.beta.q = solve(t(X) %*% X + Lambda.beta.0)#
a.gamma.q = a.0 + ncol(K.gamma)/2#
a.delta.q = a.0 + ncol(K.delta)/2#
#
Xmu.beta.q = X %*% mu.beta.q#
tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
mu.Z.star = rep(0, N)#
new.mu.alpha.q = mu.alpha.q#
new.b.delta.q = b.delta.q#
epsilon = 10^(-5)#
L = NULL#
for(i in 1:10000){#
#
## Step 2: 0.128#
  mu.Z.q = rep(mu.alpha.q, ni) + Xmu.beta.q#
  numer = dnorm(-mu.Z.q)#
  denom = pnorm(-mu.Z.q)#
  mu.Z.star[Y == 1] = mu.Z.q[Y==1] + numer[Y == 1]/(1-denom[Y==1])#
  mu.Z.star[Y == 0] = mu.Z.q[Y==0] - numer[Y == 0]/denom[Y==0]#
#
  ## Step 3: 0.044#
  mu.beta.q = t(t(mu.Z.star - rep(mu.alpha.q,ni)) %*% X %*% Sigma.beta.q)#
  Xmu.beta.q = X %*% mu.beta.q#
#
  ## Step 4: 0.024#
  Sigma.alpha.q = matrix(1/(ni + tau.star))#
  mu.alpha.q = (rowsum(mu.Z.star - Xmu.beta.q, groups.index) + (S%*%mu.gamma.q)*tau.star) * Sigma.alpha.q#
  #mu.alpha.q = alpha#
  #Sigma.alpha.q = matrix(rep(1/1000, n))#
  ## Step 5: 0.000#
  E.resid = Sigma.alpha.q + mu.alpha.q^2 - 2*mu.alpha.q*(S %*% mu.gamma.q) + rowSums((S %*% (Sigma.gamma.q + mu.gamma.q %*% t(mu.gamma.q))) * S)#
  weighted.list = lapply(1:n, function(i) S.list[[i]]*E.resid[i]*tau.star[i])#
  Sigma.delta.q = solve(a.delta.q/b.delta.q * K.delta + 0.5*Reduce("+", S.list))#
  mu.delta.q = mu.delta.q + Sigma.delta.q %*% (-(a.delta.q/b.delta.q*K.delta)%*%mu.delta.q + 0.5*colSums(c(1-tau.star*E.resid)*S))#
  tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
#
  ## Step 6: 0.000#
  tau.starS = c(tau.star) * S#
  Sigma.gamma.q = solve(t(S) %*% tau.starS + a.gamma.q/b.gamma.q * K.gamma)#
  mu.gamma.q = t(t(mu.alpha.q) %*% tau.starS %*% Sigma.gamma.q)#
#
  ## Step 7:#
  #old.b.gamma.q = b.gamma.q#
  b.gamma.q = as.numeric(b.0 + 0.5*(tr(K.gamma %*% Sigma.gamma.q) + t(mu.gamma.q)%*%K.gamma%*%mu.gamma.q))#
  #b.gamma.q = 0.001#
  ## Step 8:#
  b.delta.q = as.numeric(b.0 + 0.5*(tr(K.delta %*% Sigma.delta.q) + t(mu.delta.q)%*%K.delta%*%mu.delta.q))#
  #b.delta.q = 0.001#
  old.mu.alpha.q = new.mu.alpha.q#
  new.mu.alpha.q = mu.alpha.q#
#
  old.b.delta.q = new.b.delta.q#
  new.b.delta.q = b.delta.q#
#
  #if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon && abs(a.delta.q/old.b.delta.q - a.delta.q/new.b.delta.q) < epsilon) break#
  if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon) break#
  #if(abs(old.b.gamma.q - b.gamma.q) < epsilon) break#
  cat(paste(i, "Beta error:   ", mean((mu.beta.q - beta)^2), "  "))#
  cat(paste("Alpha error:   ", mean((mu.alpha.q - alpha)^2), "\n"))#
  cat(paste("lambda.gamma:   ", a.gamma.q / b.gamma.q, "   lambda.delta:   ", a.delta.q / b.delta.q,  "\n"))#
  par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)#
}
2^4
expand.grid(0:1, 0:1, 0:1, 0:1)
rowSums(expand.grid(0:1, 0:1, 0:1, 0:1))
rowSums(expand.grid(0:1, 0:1, 0:1, 0:1)) >= 0
rowSums(expand.grid(0:1, 0:1, -0:1, -0:1)) >= 0
rowSums(expand.grid(0:1, 0:1, -c(0:1), -c(0:1))) >= 0
sum(rowSums(expand.grid(0:1, 0:1, -c(0:1), -c(0:1))) >= 0)
3*0.5^2-
2
3*0.5^2
3*0.5^2 - 2*0.5^3
rowSums(expand.grid(c(-1, 1), c(-1, 1), c(-1, 1))) >= 0
sum(rowSums(expand.grid(c(-1, 1), c(-1, 1), c(-1, 1))) >= 0)
expand.grid(c(-1, 1), c(-1, 1), c(-1, 1))
32/3
2/3
3/5
expand.grid(c(-1, 1), c(-1, 1))
rowSums(expand.grid(c(-1, 1), c(-1, 1)))
2^3
expand.grid(c(-1, 1), c(-1, 1), c(-1, 1))
games = expand.grid(c(-1, 1), c(-1, 1), c(-1, 1))
games
ifelse(games[,1] == 1, 3/4, 1/2)
E2 = ifelse(games[,1] == 1, 3/4, 1/2)
E2
E1 = ifelse(sum(games[,1:2]) == 2, 1, ifelse(sum(games[,1:2]) == 0, 1/2, 0))
E1
E1 = ifelse(rowSums(games[,1:2]) == 2, 1, ifelse(rowSums(games[,1:2]) == 0, 1/2, 0))
E1
cor(E1, E2)
sqrt(2)
sqrt(2)/2
n = 2000#
cluster.size = 100#
p = 27#
#
#ni = rep(cluster.size, n)#
#ni = round(runif(n, 1, 100))#
#ni = sort(round(rgamma(n, 2, 20)*1000)+1)#
ni = sort(round(rexp(n, 1)*100)+1)#
N = sum(ni)#
#
library(splines)#
#s = runif(n, 0, 2)*1:n/n#
#s = rep(ni,ni)#
#s = scale(ni)#
#s = scale(s)#
s = ni#
urban = sapply(s, function(x) sample(0:1, 1, replace = TRUE, prob = c(1-0.5+1/(x+1), 0.5+1/(x+1)))#
nknots = 4
Simulate data:#
n = 4300#
#n = 2000#
cluster.size = 100#
p = 27#
#
#ni = rep(cluster.size, n)#
#ni = round(runif(n, 1, 100))#
#ni = sort(round(rgamma(n, 2, 20)*1000)+1)#
ni = sort(round(rexp(n, 1)*100)+1)#
N = sum(ni)#
#
library(splines)#
#s = runif(n, 0, 2)*1:n/n#
#s = rep(ni,ni)#
#s = scale(ni)#
#s = scale(s)#
s = ni#
urban = sapply(s, function(x) sample(0:1, 1, replace = TRUE, prob = c(1-0.5+1/(x+1), 0.5+1/(x+1)))#
nknots = 4
urban = sapply(s, function(x) sample(0:1, 1, replace = TRUE, prob = c(1-0.5+1/(x+1), 0.5+1/(x+1))))
urgab
urban
plot(urban~s)
plot(urban~s)
bspl2.2 <- create.bspline.basis(norder=4, breaks= quantile(s))#
S.true <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S.true)
library(fda)#
bspl2.2 <- create.bspline.basis(norder=4, breaks= quantile(s))#
S.true <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S.true)
Su.true <- getbasismatrix(s[urban], bspl2.2, returnMatrix=TRUE)
dim(Su.true)
dim(S.true)
nrow
nco
ncol
S.trueB = matrix(0, nrow(S.true.A), ncol(S.true.A))
S.trueA <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
Su.true <- getbasismatrix(s[urban], bspl2.2, returnMatrix=TRUE)#
S.trueB = matrix(0, nrow(S.trueA), ncol(S.trueA))
S.trueA <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
S.trueB = matrix(0, nrow(S.trueA), ncol(S.trueA))#
S.trueB[urban,] = getbasismatrix(s[urban], bspl2.2, returnMatrix=TRUE)
head(S.trueB)
head(S.trueB, 50)
S.trueB
urban
s[urgab]
s[urgan]
s[urban]
plot(urban~s)
s[urban == 1]
S.trueA <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
S.trueB = matrix(0, nrow(S.trueA), ncol(S.trueA))#
S.trueB[urban,] = getbasismatrix(s[urban==1], bspl2.2, returnMatrix=TRUE)
S.trueB
s[urban==1]
S.trueA <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
S.trueB = matrix(0, nrow(S.trueA), ncol(S.trueA))#
S.trueB[urban==1,] = getbasismatrix(s[urban==1], bspl2.2, returnMatrix=TRUE)
S.trueB
S.true = cbind(S.trueA, S.trueB)
dim(S.true)
dim(S.trueA)
gammaA = c(0, -0.1, -0.3, -0.4, -0.5, -1, -1.2)#
plot( S.trueA %*% gamma~s)
gammaA = c(0, -0.1, -0.3, -0.4, -0.5, -1, -1.2)#
plot( S.trueA %*% gammaA~s)
gammaB = c(0, -0.1, -0.3, -0.4, -0.5, -1, -1.2)#
plot( S.trueB %*% gammaB~s)
gammaB = c(0, -0.1, -0.3, -0.4, -0.5, -1, -1.2)#
plot( S.trueB %*% gammaB~s)
gammaB = c(0, -0.1, -0.2, -0.4, -0.5, -1, -1.2)#
plot( S.trueB %*% gammaB~s)
gammaB = c(0, -0.1, -0.15, -0.4, -0.5, -1, -1.2)#
plot( S.trueB %*% gammaB~s)
gammaB = c(0, -0.1, -0.15, -0.2, -0.5, -1, -1.2)#
plot( S.trueB %*% gammaB~s)
gammaB = c(0, -0.1, -0.15, -0.2, -0.25, -1, -1.2)#
plot( S.trueB %*% gammaB~s)
gammaB = c(0, -0.1, -0.15, -0.2, -0.25, -35, -1.2)#
plot( S.trueB %*% gammaB~s)
gammaB = c(0, -0.1, -0.15, -0.2, -0.25, -0.35, -1.2)#
plot( S.trueB %*% gammaB~s)
gammaB = c(0, -0.1, -0.15, -0.2, -0.25, -0.35, -0.5)#
plot( S.trueB %*% gammaB~s)
gammaA = c(0, -0.1, -0.3, -0.4, -0.5, -1, -1.2)#
plot( S.trueA %*% gammaA~s)#
gammaB = c(0, -0.1, -0.3, -0.4, -0.5, -1, -1.2)#
plot( S.trueB %*% gammaB~s)
gamma = append(gammaA, gammaB)
gamma
plot(gamma~)
plot( S.true %*% gamma~s)
deltaA = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueA %*% deltaA)~s)
deltaB = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueB %*% deltaB)~s)
deltaB = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueB %*% deltaB)~s)
deltaB = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueB %*% deltaB)~s)
deltaB = c(1,2,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueB %*% deltaB)~s)
deltaB = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueB %*% deltaB)~s)
deltaB = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueB %*% deltaB)~s)delta = append(deltaA, deltaB)#
plot( S.true %*% delta~s)
deltaA = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueA %*% deltaA)~s)#
deltaB = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueB %*% deltaB)~s)#
delta = append(deltaA, deltaB)#
plot( S.true %*% delta~s)
deltaA = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueA %*% deltaA)~s)#
deltaB = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueB %*% deltaB)~s)#
delta = append(deltaA, deltaB)#
plot( exp(-S.true %*% delta)~s)
deltaA = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueA %*% deltaA)~s)#
deltaB = c(1,1,2, 1, 1.2, 2, 2)#
plot( exp(-S.trueB %*% deltaB)~s)#
delta = append(deltaA, deltaB)#
plot( exp(-S.true %*% delta)~s)
deltaA = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueA %*% deltaA)~s)#
deltaB = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueB %*% deltaB)~s)#
delta = append(deltaA, deltaB)#
plot( exp(-S.true %*% delta)~s)
deltaA = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueA %*% deltaA)~s)#
deltaB = c(0.5,0.5,0.5, 0.5, 1.2, 2, 2)#
plot( exp(-S.trueB %*% deltaB)~s)#
delta = append(deltaA, deltaB)#
plot( exp(-S.true %*% delta)~s)
deltaA = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueA %*% deltaA)~s)#
deltaB = c(1,1,1, 1, 1.2, 2, 2)/2#
plot( exp(-S.trueB %*% deltaB)~s)#
delta = append(deltaA, deltaB)#
plot( exp(-S.true %*% delta)~s)
deltaA = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueA %*% deltaA)~s)#
deltaB = c(1,1,1, 1, 1.2, 2, 2)/2#
plot( exp(-S.trueB %*% deltaB)~s)#
delta = append(deltaA, deltaB)#
plot( exp(-S.true %*% delta)~s)
4
deltaA = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueA %*% deltaA)~s)#
deltaB = c(1,1,1, 1, 1.2, 2, 2)/4#
plot( exp(-S.trueB %*% deltaB)~s)#
delta = append(deltaA, deltaB)#
plot( exp(-S.true %*% delta)~s)
deltaA = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueA %*% deltaA)~s)#
deltaB = c(1,1,1, 1, 1.2, 1, 1)/4#
plot( exp(-S.trueB %*% deltaB)~s)#
delta = append(deltaA, deltaB)#
plot( exp(-S.true %*% delta)~s)
deltaA = c(1,1,1, 1, 1.2, 2, 2)#
plot( exp(-S.trueA %*% deltaA)~s)#
deltaB = c(1,1,1, 1, 1.2, 1, 1)/4#
plot( exp(-S.trueB %*% deltaB)~s)#
delta = append(deltaA, deltaB)#
plot( exp(-S.true %*% delta)~s)
alpha = rnorm(n, S.true %*% gamma, sqrt(exp(-S.true %*% delta))) #
alpha.rep = rep(alpha, ni)#
plot(alpha~s)
In our model, X cannot have an intercept term. This makes the model#
# non-identifiable. Also, be careful with the simulated structure of#
# the predictors.#
X = sapply(1:p, function(x) runif(N, -1, 1)*1:N/N)#
#X = sapply(1:p, function(x) runif(N, -1, 1)*1:N/N)#
#X = rep(1:cluster.size/cluster.size, n)#
#X = cbind(rep(-(cluster.size:1)/cluster.size, n), X)#
beta = sample(c(-1,1), p, replace = TRUE)*(1:p)/p#
eta = alpha.rep + X %*% beta#
probs = pnorm(eta)#
Y = sapply(1:N, function(x) rbinom(1,1,probs[x]))#
#
#library(MASS)#
#dd = data.frame(Y,X)#
#ID = rep(1:n,ni)#
#glmm = glmmPQL(Y~-1+X1+X2+X3+X4+X5+X6+X7+X8+X9+X10+X11+X12+X13+X14+X15+X16+X17+X18+X19+X20+X21+X22+X23+X24+X25+X26+X27, random  = ~1 | ID,family = binomial, data = dd)
S.trueA <- bs(s, intercept = TRUE, knots = knots)
sS.trueA <- bs(s, intercept = TRUE, knots = knots)
S.trueA <- bs(s, intercept = TRUE, knots = knots)
s
knots
knots = round(diff(range(s))/(nknots+1)*1:nknots)
Run the algorithm:#
# PRIORS:#
nknots = 20#
groups.index = rep(1:n, ni)#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
#knots = quantile(s, seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = round(diff(range(s))/(nknots+1)*1:nknots)#
#knots = diff(range(s))/(nknots+1)*1:nknots
knots
S.trueA <- bs(s, intercept = TRUE, knots = knots)
SA <- bs(s, intercept = TRUE, knots = knots)#
SB = matrix(0, nrow(S.trueA), ncol(S.trueA))#
SB[urban==1,] =  bs(s[urban == 1], intercept = TRUE, knots = knots)#
S = cbind(SA, SB)
S
r = ncol(S)
r
Run the algorithm:#
# PRIORS:#
nknots = 20#
groups.index = rep(1:n, ni)#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
#knots = quantile(s, seq(0, 1, length = nknots + 2)[-c(1, nknots+2)])#
knots = round(diff(range(s))/(nknots+1)*1:nknots)#
#knots = diff(range(s))/(nknots+1)*1:nknots#
#
SA <- bs(s, intercept = TRUE, knots = knots)#
SB = matrix(0, nrow(S.trueA), ncol(S.trueA))#
SB[urban==1,] =  bs(s[urban == 1], intercept = TRUE, knots = knots)#
S = cbind(SA, SB)#
#knots = quantile(s[groups.index], seq(0, 1, length = nknots + 2))#
#knots = quantile(s, seq(0, 1, length = nknots + 2))#
#S = bs(s, intercept = TRUE, knots = knots)#
#S = ns(s, intercept = TRUE, knots = knots)#
#r = ncol(S)#
#bspl2.2 <- create.bspline.basis(norder=4, breaks= knots)#
#S <- getbasismatrix(s, bspl2.2, returnMatrix=TRUE)#
r = ncol(S)#
#
## The goal with this fix is to reduce the wiggliness at the high-end#
## where only a few observations are given. It is reasonable to assume#
## that with only a few widely spread out observations, the line#
## through the data is the best option.#
library(ppls)#
K = Penalty.matrix(c(ncol(S)),2)#
diags <- list(rep(1, r), rep(-2, r), rep(1, r))#
A <- bandSparse(r, k = c(0:2), diag =diags, symm=FALSE)#
A = as.matrix(A)#
A[1:2, 1:2] = 0#
counts = apply(S, 2, function(x) sum(x > 0))#
counts = ifelse(counts == 0, 10^{-6}, counts)#
#K.gamma = A %*% diag(1/counts) %*% t(A)#
K.gamma = A %*% t(A)#
K.delta = A %*% t(A)#
#K.delta = K.gamma#
#
a.0 = 1#
#b.0 = 10^{-6}#
#a.0 = 0.001#
b.0 = 0.0001#
Lambda.beta.0 = 1/1000*diag(p)#
# INITIALIZE:#
mu.alpha.q = matrix(rep(0, n))#
mu.beta.q = matrix(rep(0, p))#
#mu.alpha.q = glmm$coefficients$random[[1]]#
#mu.beta.q = glmm$coefficients$fixed#
mu.gamma.q = matrix(rep(0, r))#
mu.delta.q = matrix(rep(0, r))#
Sigma.gamma.q = diag(r)#
Sigma.delta.q = diag(r)#
b.gamma.q = b.0#
b.delta.q = b.0#
tr = function(X) sum(diag(X))#
# START:#
library(Matrix)#
#groups = as.matrix(bdiag(lapply(1:n, function(x) rep(1,ni[x]))))#
#
## Step 1:#
S.list = lapply(1:n, function(i) S[i,] %*% t(S[i,]))#
Sigma.beta.q = solve(t(X) %*% X + Lambda.beta.0)#
a.gamma.q = a.0 + ncol(K.gamma)/2#
a.delta.q = a.0 + ncol(K.delta)/2#
#
Xmu.beta.q = X %*% mu.beta.q#
tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
mu.Z.star = rep(0, N)#
new.mu.alpha.q = mu.alpha.q#
new.b.delta.q = b.delta.q#
epsilon = 10^(-5)#
L = NULL#
for(i in 1:10000){#
#
## Step 2: 0.128#
  mu.Z.q = rep(mu.alpha.q, ni) + Xmu.beta.q#
  numer = dnorm(-mu.Z.q)#
  denom = pnorm(-mu.Z.q)#
  mu.Z.star[Y == 1] = mu.Z.q[Y==1] + numer[Y == 1]/(1-denom[Y==1])#
  mu.Z.star[Y == 0] = mu.Z.q[Y==0] - numer[Y == 0]/denom[Y==0]#
#
  ## Step 3: 0.044#
  mu.beta.q = t(t(mu.Z.star - rep(mu.alpha.q,ni)) %*% X %*% Sigma.beta.q)#
  Xmu.beta.q = X %*% mu.beta.q#
#
  ## Step 4: 0.024#
  Sigma.alpha.q = matrix(1/(ni + tau.star))#
  mu.alpha.q = (rowsum(mu.Z.star - Xmu.beta.q, groups.index) + (S%*%mu.gamma.q)*tau.star) * Sigma.alpha.q#
  #mu.alpha.q = alpha#
  #Sigma.alpha.q = matrix(rep(1/1000, n))#
  ## Step 5: 0.000#
  E.resid = Sigma.alpha.q + mu.alpha.q^2 - 2*mu.alpha.q*(S %*% mu.gamma.q) + rowSums((S %*% (Sigma.gamma.q + mu.gamma.q %*% t(mu.gamma.q))) * S)#
  weighted.list = lapply(1:n, function(i) S.list[[i]]*E.resid[i]*tau.star[i])#
  Sigma.delta.q = solve(a.delta.q/b.delta.q * K.delta + 0.5*Reduce("+", S.list))#
  mu.delta.q = mu.delta.q + Sigma.delta.q %*% (-(a.delta.q/b.delta.q*K.delta)%*%mu.delta.q + 0.5*colSums(c(1-tau.star*E.resid)*S))#
  tau.star = exp(S %*% mu.delta.q + rowSums((S %*% Sigma.delta.q)*S)/2)#
#
  ## Step 6: 0.000#
  tau.starS = c(tau.star) * S#
  Sigma.gamma.q = solve(t(S) %*% tau.starS + a.gamma.q/b.gamma.q * K.gamma)#
  mu.gamma.q = t(t(mu.alpha.q) %*% tau.starS %*% Sigma.gamma.q)#
#
  ## Step 7:#
  #old.b.gamma.q = b.gamma.q#
  b.gamma.q = as.numeric(b.0 + 0.5*(tr(K.gamma %*% Sigma.gamma.q) + t(mu.gamma.q)%*%K.gamma%*%mu.gamma.q))#
  #b.gamma.q = 0.001#
  ## Step 8:#
  b.delta.q = as.numeric(b.0 + 0.5*(tr(K.delta %*% Sigma.delta.q) + t(mu.delta.q)%*%K.delta%*%mu.delta.q))#
  #b.delta.q = 0.001#
  old.mu.alpha.q = new.mu.alpha.q#
  new.mu.alpha.q = mu.alpha.q#
#
  old.b.delta.q = new.b.delta.q#
  new.b.delta.q = b.delta.q#
#
  #if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon && abs(a.delta.q/old.b.delta.q - a.delta.q/new.b.delta.q) < epsilon) break#
  if(sum((old.mu.alpha.q - new.mu.alpha.q)^2) < epsilon) break#
  #if(abs(old.b.gamma.q - b.gamma.q) < epsilon) break#
  cat(paste(i, "Beta error:   ", mean((mu.beta.q - beta)^2), "  "))#
  cat(paste("Alpha error:   ", mean((mu.alpha.q - alpha)^2), "\n"))#
  cat(paste("lambda.gamma:   ", a.gamma.q / b.gamma.q, "   lambda.delta:   ", a.delta.q / b.delta.q,  "\n"))#
  par(mfrow = c(1,2))#
  plot( (S.true %*% gamma)~s)#
  points((S %*% mu.gamma.q)~s, col = 2)#
  plot( exp(-S.true %*% delta)~s)#
  points( exp(-S %*% mu.delta.q)~s, col = 2)#
}
library(lattice)#
N = 10#
#deltas = seq(0.001, 2/N, length = 500)#
deltas = seq(0.001, 0.999, length = 500)#
rhos = seq(0.001, 1, length = 500)#
grid = expand.grid(deltas, rhos)#
#grid =  grid[grid[,2] < grid[,1], ]#
thresh = (N-1/grid[,1])/(N-1)#
grid = grid[thresh <= grid[,2] ,]#
#
alphas = N/((N-1)*grid[,2] + 1) / sqrt(1-N*grid[,1]/((N-1)*grid[,2] + 1))#
grid = cbind(alphas, grid)#
#col.l = c(colorRampPalette(c('darkblue', 'skyblue'))(9), colorRampPalette(c('darksalmon', 'darkred'))(11))#
#
alphas = log(alphas)#
L = 50#
#col.l =  colorRampPalette(c('coral', 'coral4', 'darkred'))(L)#
col.l = colorRampPalette(c("yellow","red", "darkred", "black"))(L) #
#ats = seq(1, max(alphas, na.rm = TRUE), length = L)#
#ats = ats[-10]#
ats = seq(min(alphas), max(alphas), length = L)
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, pretty = TRUE, at = ats, contour = TRUE)
?leveplot
?levelplot
p.strip <- list(cex=1.5, lines=2, fontface='bold')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip)
p.strip <- list(cex=5, lines=2, fontface='bold')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip)
p.strip <- list(cex=5, lines=100, fontface='bold')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip)
scales=list(x=x.scale, y=y.scale)#
y.scale <- list(cex=1, alternating=1, col='blue')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))
x.scale <- list(cex=1, alternating=1, col='red')#
y.scale <- list(cex=1, alternating=1, col='blue')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))
x.scale <- list(cex=2, alternating=1, col='black')#
y.scale <- list(cex=2, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))
x.scale <- list(cex=1.5, alternating=1, col='black')#
y.scale <- list(cex=1.5, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))
x.scale <- list(cex=1.5, alternating=1, col='black')#
y.scale <- list(cex=1.5, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))p.strip <- list(cex=1.5, lines=2, fontface='bold')#
x.scale <- list(cex=1.5, alternating=1, col='black')#
y.scale <- list(cex=1.5, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))
p.strip <- list(cex=1.5, lines=2, fontface='bold')#
ckey <- list(labels=list(cex=1.5, col='magenta'), height=0.5)#
x.scale <- list(cex=1.5, alternating=1, col='black')#
y.scale <- list(cex=1.5, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, colorkey=ckey, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))
p.strip <- list(cex=1, lines=2, fontface='bold')#
ckey <- list(labels=list(cex=1.5, col='magenta'), height=0.5)#
x.scale <- list(cex=1.5, alternating=1, col='black')#
y.scale <- list(cex=1.5, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, colorkey=ckey, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))
p.strip <- list(cex=1, lines=2, fontface='bold')#
ckey <- list(labels=list(cex=1.5, col='magenta'), height=0.5)#
x.scale <- list(cex=1.5, alternating=1, col='black')#
y.scale <- list(cex=1.5, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, colorkey=ckey, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))#
p.strip <- list(cex=1.5, lines=2, fontface='bold')#
ckey <- list(labels=list(cex=1.5, col='black'), height=0.5)#
x.scale <- list(cex=1.5, alternating=1, col='black')#
y.scale <- list(cex=1.5, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, colorkey=ckey, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))
p.strip <- list(cex=1.5, lines=2, fontface='bold')#
ckey <- list(labels=list(cex=1.5, col='black'), height=1.5)#
x.scale <- list(cex=1.5, alternating=1, col='black')#
y.scale <- list(cex=1.5, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, colorkey=ckey, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))
ckey <- list(labels=list(cex=1.5, col='black'))#
x.scale <- list(cex=1.5, alternating=1, col='black')#
y.scale <- list(cex=1.5, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, colorkey=ckey, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))
? levelplot
N
setwd("/Users/ville/extremization_paper/")#
jpeg(paste("ExtremeN", N, ".jpeg", sep= ""), pointsize = 15)#
#
p.strip <- list(cex=1.5, lines=2, fontface='bold')#
#ckey <- list(labels=list(cex=1.5, col='black'), height=1.5)#
ckey <- list(labels=list(cex=1.5, col='black'))#
x.scale <- list(cex=1.5, alternating=1, col='black')#
y.scale <- list(cex=1.5, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, colorkey=ckey, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))#
#
dev.off()
setwd("/Users/ville/extremization_paper/")#
jpeg(paste("ExtremeN", N, ".jpeg", sep= ""), pointsize = 15)#
#
p.strip <- list(cex=2, lines=2, fontface='bold')#
#ckey <- list(labels=list(cex=1.5, col='black'), height=1.5)#
ckey <- list(labels=list(cex=2, col='black'))#
x.scale <- list(cex=2, alternating=1, col='black')#
y.scale <- list(cex=2, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, colorkey=ckey, pretty = TRUE, at = ats, contour = TRUE,par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))#
#
dev.off()
p.strip <- list(cex=1.5, lines=2, fontface='bold')#
#ckey <- list(labels=list(cex=1.5, col='black'), height=1.5)#
ckey <- list(labels=list(cex=1.5, col='black'))#
x.scale <- list(cex=1.5, alternating=1, col='black')#
y.scale <- list(cex=1.5, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, colorkey=ckey, pretty = TRUE, at = ats, contour = TRUE, par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))
p.strip <- list(cex=1.5, lines=10, fontface='bold')#
#ckey <- list(labels=list(cex=1.5, col='black'), height=1.5)#
ckey <- list(labels=list(cex=1.5, col='black'))#
x.scale <- list(cex=1.5, alternating=1, col='black')#
y.scale <- list(cex=1.5, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = expression(delta), col.regions = col.l, colorkey=ckey, pretty = TRUE, at = ats, contour = TRUE, par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))
levelplot(alphas~grid[,2]+grid[,3], ylab = expression(rho), xlab = list( label = expression(delta), cex = 1.5), col.regions = col.l, colorkey=ckey, pretty = TRUE, at = ats, contour = TRUE, par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))
levelplot(alphas~grid[,2]+grid[,3], ylab = list(label = expression(rho), cex = 1.5), xlab = list( label = expression(delta), cex = 1.5), col.regions = col.l, colorkey=ckey, pretty = TRUE, at = ats, contour = TRUE, par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))
setwd("/Users/ville/extremization_paper/")#
jpeg(paste("ExtremeN", N, ".jpeg", sep= ""), pointsize = 15)#
#
p.strip <- list(cex=1.5, lines=2, fontface='bold')#
#ckey <- list(labels=list(cex=1.5, col='black'), height=1.5)#
ckey <- list(labels=list(cex=1.5, col='black'))#
x.scale <- list(cex=1.5, alternating=1, col='black')#
y.scale <- list(cex=1.5, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = list(label = expression(rho), cex = 1.5), xlab = list( label = expression(delta), cex = 1.5), col.regions = col.l, colorkey=ckey, pretty = TRUE, at = ats, contour = TRUE, par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))#
#
dev.off()
N = 5#
#deltas = seq(0.001, 2/N, length = 500)#
deltas = seq(0.001, 0.999, length = 500)#
rhos = seq(0.001, 1, length = 500)#
grid = expand.grid(deltas, rhos)#
#grid =  grid[grid[,2] < grid[,1], ]#
thresh = (N-1/grid[,1])/(N-1)#
grid = grid[thresh <= grid[,2] ,]#
#
alphas = N/((N-1)*grid[,2] + 1) / sqrt(1-N*grid[,1]/((N-1)*grid[,2] + 1))#
grid = cbind(alphas, grid)#
#col.l = c(colorRampPalette(c('darkblue', 'skyblue'))(9), colorRampPalette(c('darksalmon', 'darkred'))(11))#
#
alphas = log(alphas)#
L = 50#
#col.l =  colorRampPalette(c('coral', 'coral4', 'darkred'))(L)#
col.l = colorRampPalette(c("yellow","red", "darkred", "black"))(L) #
#ats = seq(1, max(alphas, na.rm = TRUE), length = L)#
#ats = ats[-10]#
ats = seq(min(alphas), max(alphas), length = L)#
setwd("/Users/ville/extremization_paper/")#
jpeg(paste("ExtremeN", N, ".jpeg", sep= ""), pointsize = 15)#
#
p.strip <- list(cex=1.5, lines=2, fontface='bold')#
#ckey <- list(labels=list(cex=1.5, col='black'), height=1.5)#
ckey <- list(labels=list(cex=1.5, col='black'))#
x.scale <- list(cex=1.5, alternating=1, col='black')#
y.scale <- list(cex=1.5, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = list(label = expression(rho), cex = 1.5), xlab = list( label = expression(delta), cex = 1.5), col.regions = col.l, colorkey=ckey, pretty = TRUE, at = ats, contour = TRUE, par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))#
#
dev.off()
N = 2#
#deltas = seq(0.001, 2/N, length = 500)#
deltas = seq(0.001, 0.999, length = 500)#
rhos = seq(0.001, 1, length = 500)#
grid = expand.grid(deltas, rhos)#
#grid =  grid[grid[,2] < grid[,1], ]#
thresh = (N-1/grid[,1])/(N-1)#
grid = grid[thresh <= grid[,2] ,]#
#
alphas = N/((N-1)*grid[,2] + 1) / sqrt(1-N*grid[,1]/((N-1)*grid[,2] + 1))#
grid = cbind(alphas, grid)#
#col.l = c(colorRampPalette(c('darkblue', 'skyblue'))(9), colorRampPalette(c('darksalmon', 'darkred'))(11))#
#
alphas = log(alphas)#
L = 50#
#col.l =  colorRampPalette(c('coral', 'coral4', 'darkred'))(L)#
col.l = colorRampPalette(c("yellow","red", "darkred", "black"))(L) #
#ats = seq(1, max(alphas, na.rm = TRUE), length = L)#
#ats = ats[-10]#
ats = seq(min(alphas), max(alphas), length = L)#
setwd("/Users/ville/extremization_paper/")#
jpeg(paste("ExtremeN", N, ".jpeg", sep= ""), pointsize = 15)#
#
p.strip <- list(cex=1.5, lines=2, fontface='bold')#
#ckey <- list(labels=list(cex=1.5, col='black'), height=1.5)#
ckey <- list(labels=list(cex=1.5, col='black'))#
x.scale <- list(cex=1.5, alternating=1, col='black')#
y.scale <- list(cex=1.5, alternating=1, col='black')#
levelplot(alphas~grid[,2]+grid[,3], ylab = list(label = expression(rho), cex = 1.5), xlab = list( label = expression(delta), cex = 1.5), col.regions = col.l, colorkey=ckey, pretty = TRUE, at = ats, contour = TRUE, par.strip.text=p.strip, scales=list(x=x.scale, y=y.scale))#
#
dev.off()
Sigma = matrix(0, 3,3)
Sigma
diag(Sigma) = 1
Sigma
Sigma[1,2] = Sigma[2,1] = 0.85
Sigma
Sigma[1,3] = Sigma[3,1] = 0.33
Sigma
Sigma[2,3]
Sigma[2,3] = Sigma[3,2] = 0.76
Sigma
Sigma/3
round(Sigma/3)
round(Sigma/3, 3)
round(Sigma/3, 2)
Sigma2 = round(Sigma/3, 2)
Sigma
Sigma2
mvtrnorm
mvrnorm(1, 0, Sigma2)
mvrnorm(1, rep(0,3), Sigma2)
mvrnorm(1, rep(0,3), Sigma2)
mvrnorm(1, rep(0,3), Sigma2)
mvrnorm(1, rep(0,3), Sigma2)
Sigma
Sigma2
